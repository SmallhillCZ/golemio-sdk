/* tslint:disable */
/* eslint-disable */
/**
 * üöã Public Transport | Golemio API
 * <p><img src=\"https://storage.golemio.cz/golemiocz/images/golemioapi_logos.png\" alt=\"Logos\" /></p> <p><b>Toto je ƒç√°st dokumentace REST API projektu pra≈æsk√© datov√© platformy Golemio, kter√° obsahuje popis Public Transport Output Gateway API.</b></p> <p>Ve≈°ker√© dotazy pros√≠m smƒõ≈ôujte na <a href=\"mailto:golemio@operatorict.cz?subject=golemioapi\">golemio@operatorict.cz</a>.</p> <p>Dokumentace je v anglick√©m jazyce. V√≠ce informac√≠ o projektu naleznete na <a href=\"https://www.golemio.cz/\">www.golemio.cz</a>.</p> <H1>Description</H1> <p><b>This documentation covers the RESTful API of the Golemio Prague Data Platform project, specifically detailing the Public Transport Output Gateway API.</b></p> <p>Support is accessible via <a href=\"mailto:golemio@operatorict.cz?subject=golemioapi\">golemio@operatorict.cz</a>.</p> <p>For more information about Golemio, please visit the website <a href=\"https://www.golemio.cz/\">www.golemio.cz</a>.</p> <H2>Golemio API documentation:</H2> <li><a href=\"https://api.golemio.cz/docs/openapi/\">Main Golemio API</a></li> <li><a href=\"https://api.golemio.cz/docs/public-openapi/\">Open Data Golemio API</a></li> <li><a href=\"https://api.golemio.cz/input-gateway/docs/openapi/\">Golemio Input Gateway API</a></li> <li>üëâ Public Transport Golemio API</li> <li><a href=\"https://api.golemio.cz/pid/input-gateway/docs/openapi/\">Public Transport Golemio Input Gateway API</a></li> <H1>General info</H1> <H2>Authorization</H2> <p>Generate your token at <a href=\"https://api.golemio.cz/api-keys\">api.golemio.cz/api-keys</a>.</p> <p><b>Use the token as the value of the X-Access-Token header.</b></p> <H1>Usage</H1> <H2>Pagination</H2> <p>The API returns a maximum of 10,000 objects/rows per request. You can specify a lower number by adding the <code>?limit</code> URL parameter.</p> <p>     This limit may vary depending on the specific route; please refer to the description of parameters for each route. To retrieve more data, use multiple requests with the <code>?limit&offset</code> parameters.     Refer to the examples below. </p> <H2>Requests rate</H2> <p>By default, each API key has a rate limit of 20 requests per 8 seconds.</p> <H2>Compression</H2> <p>By default, the Content-Encoding header is set to gzip (if requested). If the raw response is less than 1 KB, the data is returned uncompressed, and the Content-Encoding header is not set.</p> <H2>General Transit Feed Specification</H2> <p>Access GTFS (<a href=\"https://developers.google.com/transit/gtfs\">General Transit Feed Specification</a>) data on the city\'s public transportation schedules through this API.</p> <p>The data is published by ROPID and remains valid for the upcoming ~12 days, subject to daily updates.</p> <p>Learn more at <a href=\"https://pid.cz/o-systemu/opendata/\">pid.cz</a>.</p> <H2>Open Data</H2> <p><img src=\"https://img.shields.io/badge/opendata-available-green\" alt=\"golemioapi-opendata-badge\" /></p> <p>This badge means it is available for public use as Open Data.</p>
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: golemio@operatorict.cz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { ConfigurationParameters as GolemioPublicTransportApiConfiguration, defaultConfigurationParameters } from './configuration';
import type { AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export { ConfigurationParameters as GolemioPublicTransportApiConfiguration } from './configuration'; 

export class GolemioPublicTransportApi {
        GTFSRealtimeV2Api: GolemioPublicTransportApi.GTFSRealtimeV2Api;
        GTFSStaticV2Api: GolemioPublicTransportApi.GTFSStaticV2Api;
        JISV1InternalApi: GolemioPublicTransportApi.JISV1InternalApi;
        PIDDepartureBoardsV2Api: GolemioPublicTransportApi.PIDDepartureBoardsV2Api;
        PIDDepartureBoardsV3Api: GolemioPublicTransportApi.PIDDepartureBoardsV3Api;
        PIDDepartureBoardsV3InternalApi: GolemioPublicTransportApi.PIDDepartureBoardsV3InternalApi;
        PIDDepartureBoardsV4Api: GolemioPublicTransportApi.PIDDepartureBoardsV4Api;
        PIDRealtimePositionsV2Api: GolemioPublicTransportApi.PIDRealtimePositionsV2Api;
        PublicDeparturesV2Api: GolemioPublicTransportApi.PublicDeparturesV2Api;
        PublicGTFSStaticLookupV2Api: GolemioPublicTransportApi.PublicGTFSStaticLookupV2Api;
        PublicVehiclePositionsV2Api: GolemioPublicTransportApi.PublicVehiclePositionsV2Api;
    
        constructor(configurationParams: GolemioPublicTransportApiConfiguration, axios?: AxiosInstance) {
            const configuration = Object.assign({}, defaultConfigurationParameters, configurationParams);

            if(!axios) axios = globalAxios.create();

            this.GTFSRealtimeV2Api = new GolemioPublicTransportApi.GTFSRealtimeV2Api(configuration, axios!);
            this.GTFSStaticV2Api = new GolemioPublicTransportApi.GTFSStaticV2Api(configuration, axios!);
            this.JISV1InternalApi = new GolemioPublicTransportApi.JISV1InternalApi(configuration, axios!);
            this.PIDDepartureBoardsV2Api = new GolemioPublicTransportApi.PIDDepartureBoardsV2Api(configuration, axios!);
            this.PIDDepartureBoardsV3Api = new GolemioPublicTransportApi.PIDDepartureBoardsV3Api(configuration, axios!);
            this.PIDDepartureBoardsV3InternalApi = new GolemioPublicTransportApi.PIDDepartureBoardsV3InternalApi(configuration, axios!);
            this.PIDDepartureBoardsV4Api = new GolemioPublicTransportApi.PIDDepartureBoardsV4Api(configuration, axios!);
            this.PIDRealtimePositionsV2Api = new GolemioPublicTransportApi.PIDRealtimePositionsV2Api(configuration, axios!);
            this.PublicDeparturesV2Api = new GolemioPublicTransportApi.PublicDeparturesV2Api(configuration, axios!);
            this.PublicGTFSStaticLookupV2Api = new GolemioPublicTransportApi.PublicGTFSStaticLookupV2Api(configuration, axios!);
            this.PublicVehiclePositionsV2Api = new GolemioPublicTransportApi.PublicVehiclePositionsV2Api(configuration, axios!);
        };
}

export namespace GolemioPublicTransportApi {

        /**
     * 
     * @export
     * @interface ASWid
     */
    export interface ASWid {
        /**
         * ASW ID of node
         * @type {number}
         * @memberof ASWid
         */
        'node': number;
        /**
         * Identification of the stop within the node.
         * @type {number}
         * @memberof ASWid
         */
        'stop': number;
    }
    
        /**
     * 
     * @export
     * @interface Effect
     */
    export interface Effect {
        /**
         * 
         * @type {string}
         * @memberof Effect
         */
        'cs': string;
        /**
         * 
         * @type {string}
         * @memberof Effect
         */
        'en'?: string | null;
    }
    
        /**
     * 
     * @export
     * @interface EventCustomFormat
     */
    export interface EventCustomFormat {
        /**
         * 
         * @type {string}
         * @memberof EventCustomFormat
         */
        'id': string;
        /**
         * 
         * @type {string}
         * @memberof EventCustomFormat
         */
        'type': EventCustomFormatTypeEnum;
        /**
         * 
         * @type {EventCustomFormatHeaderText}
         * @memberof EventCustomFormat
         */
        'header_text': EventCustomFormatHeaderText;
        /**
         * 
         * @type {EventCustomFormatCause}
         * @memberof EventCustomFormat
         */
        'cause': EventCustomFormatCause;
        /**
         * 
         * @type {EventCustomFormatCauseDetail}
         * @memberof EventCustomFormat
         */
        'cause_detail': EventCustomFormatCauseDetail;
        /**
         * INFO - priority 3 \\ WARNING - priority 2 \\ SEVERE - priority 1 
         * @type {string}
         * @memberof EventCustomFormat
         */
        'severity_level': EventCustomFormatSeverityLevelEnum;
        /**
         * 
         * @type {EventCustomFormatActivePeriod}
         * @memberof EventCustomFormat
         */
        'active_period': EventCustomFormatActivePeriod;
        /**
         * 
         * @type {EventCustomFormatDisplayPeriod}
         * @memberof EventCustomFormat
         */
        'display_period': EventCustomFormatDisplayPeriod;
        /**
         * 
         * @type {Array<Effect>}
         * @memberof EventCustomFormat
         */
        'effects': Array<Effect>;
        /**
         * 
         * @type {EventCustomFormatDescriptionText}
         * @memberof EventCustomFormat
         */
        'description_text': EventCustomFormatDescriptionText;
        /**
         * 
         * @type {EventCustomFormatDescriptionHtml}
         * @memberof EventCustomFormat
         */
        'description_html': EventCustomFormatDescriptionHtml;
        /**
         * 
         * @type {string}
         * @memberof EventCustomFormat
         */
        'organization_name': string;
        /**
         * 
         * @type {EventCustomFormatInformedEntity}
         * @memberof EventCustomFormat
         */
        'informed_entity': EventCustomFormatInformedEntity | null;
        /**
         * Timestamp from when the event was last modified in VYMI
         * @type {string}
         * @memberof EventCustomFormat
         */
        'last_modified_timestamp': string;
        /**
         * Timestamp from when the event was created in VYMI
         * @type {string}
         * @memberof EventCustomFormat
         */
        'created_timestamp': string;
    }
    
    export const EventCustomFormatTypeEnum = {
        Incident: 'INCIDENT',
        Disruption: 'DISRUPTION',
        ServiceChange: 'SERVICE_CHANGE'
    } as const;
    
    export type EventCustomFormatTypeEnum = typeof EventCustomFormatTypeEnum[keyof typeof EventCustomFormatTypeEnum];
    export const EventCustomFormatSeverityLevelEnum = {
        Info: 'INFO',
        Warning: 'WARNING',
        Severe: 'SEVERE'
    } as const;
    
    export type EventCustomFormatSeverityLevelEnum = typeof EventCustomFormatSeverityLevelEnum[keyof typeof EventCustomFormatSeverityLevelEnum];
    
    
        /**
     * The start and end date/time of the event validity
     * @export
     * @interface EventCustomFormatActivePeriod
     */
    export interface EventCustomFormatActivePeriod {
        /**
         * 
         * @type {string}
         * @memberof EventCustomFormatActivePeriod
         */
        'start': string;
        /**
         * 
         * @type {string}
         * @memberof EventCustomFormatActivePeriod
         */
        'end': string | null;
    }
    
        /**
     * 
     * @export
     * @interface EventCustomFormatCause
     */
    export interface EventCustomFormatCause {
        /**
         * 
         * @type {string}
         * @memberof EventCustomFormatCause
         */
        'cs': string;
        /**
         * 
         * @type {string}
         * @memberof EventCustomFormatCause
         */
        'en'?: string | null;
    }
    
        /**
     * 
     * @export
     * @interface EventCustomFormatCauseDetail
     */
    export interface EventCustomFormatCauseDetail {
        /**
         * 
         * @type {string}
         * @memberof EventCustomFormatCauseDetail
         */
        'cs': string;
        /**
         * 
         * @type {string}
         * @memberof EventCustomFormatCauseDetail
         */
        'en'?: string | null;
    }
    
        /**
     * Localized descriptions of the event in HTML format
     * @export
     * @interface EventCustomFormatDescriptionHtml
     */
    export interface EventCustomFormatDescriptionHtml {
        /**
         * Event description in Czech in HTML format
         * @type {string}
         * @memberof EventCustomFormatDescriptionHtml
         */
        'cs': string;
        /**
         * Event description in English in HTML format
         * @type {string}
         * @memberof EventCustomFormatDescriptionHtml
         */
        'en'?: string | null;
    }
    
        /**
     * Localized descriptions of the event in plain text
     * @export
     * @interface EventCustomFormatDescriptionText
     */
    export interface EventCustomFormatDescriptionText {
        /**
         * Event description in Czech in plain text
         * @type {string}
         * @memberof EventCustomFormatDescriptionText
         */
        'cs': string;
        /**
         * Event description in English in plain text
         * @type {string}
         * @memberof EventCustomFormatDescriptionText
         */
        'en'?: string | null;
    }
    
        /**
     * The start and end date/time when the event should be displayed
     * @export
     * @interface EventCustomFormatDisplayPeriod
     */
    export interface EventCustomFormatDisplayPeriod {
        /**
         * 
         * @type {string}
         * @memberof EventCustomFormatDisplayPeriod
         */
        'start': string;
        /**
         * 
         * @type {string}
         * @memberof EventCustomFormatDisplayPeriod
         */
        'end': string | null;
    }
    
        /**
     * 
     * @export
     * @interface EventCustomFormatHeaderText
     */
    export interface EventCustomFormatHeaderText {
        /**
         * 
         * @type {string}
         * @memberof EventCustomFormatHeaderText
         */
        'cs': string;
        /**
         * 
         * @type {string}
         * @memberof EventCustomFormatHeaderText
         */
        'en'?: string | null;
    }
    
        /**
     * 
     * @export
     * @interface EventCustomFormatInformedEntity
     */
    export interface EventCustomFormatInformedEntity {
        /**
         * 
         * @type {Array<InformedEntityRoute>}
         * @memberof EventCustomFormatInformedEntity
         */
        'routes'?: Array<InformedEntityRoute> | null;
    }
    
        /**
     * 
     * @export
     * @interface FeaturePoint
     */
    export interface FeaturePoint {
        /**
         * 
         * @type {FeaturePointGeometry}
         * @memberof FeaturePoint
         */
        'geometry': FeaturePointGeometry;
        /**
         * 
         * @type {object}
         * @memberof FeaturePoint
         */
        'properties': object;
        /**
         * 
         * @type {string}
         * @memberof FeaturePoint
         */
        'type': string;
    }
    
        /**
     * 
     * @export
     * @interface FeaturePointGeometry
     */
    export interface FeaturePointGeometry {
        /**
         * 
         * @type {string}
         * @memberof FeaturePointGeometry
         */
        'type': string;
        /**
         * 
         * @type {Array<number>}
         * @memberof FeaturePointGeometry
         */
        'coordinates': Array<number>;
    }
    
        /**
     * 
     * @export
     * @interface GTFSRoute
     */
    export interface GTFSRoute {
        /**
         * 
         * @type {string}
         * @memberof GTFSRoute
         */
        'agency_id': string;
        /**
         * 
         * @type {boolean}
         * @memberof GTFSRoute
         */
        'is_night': boolean;
        /**
         * 
         * @type {boolean}
         * @memberof GTFSRoute
         */
        'is_regional': boolean;
        /**
         * 
         * @type {boolean}
         * @memberof GTFSRoute
         */
        'is_substitute_transport': boolean;
        /**
         * 
         * @type {string}
         * @memberof GTFSRoute
         */
        'last_modify'?: string | null;
        /**
         * 
         * @type {string}
         * @memberof GTFSRoute
         */
        'route_color': string;
        /**
         * 
         * @type {string}
         * @memberof GTFSRoute
         */
        'route_desc'?: string | null;
        /**
         * 
         * @type {string}
         * @memberof GTFSRoute
         */
        'route_id': string;
        /**
         * 
         * @type {string}
         * @memberof GTFSRoute
         */
        'route_long_name': string;
        /**
         * 
         * @type {string}
         * @memberof GTFSRoute
         */
        'route_short_name': string;
        /**
         * 
         * @type {string}
         * @memberof GTFSRoute
         */
        'route_text_color': string;
        /**
         * 
         * @type {number}
         * @memberof GTFSRoute
         */
        'route_type': number;
        /**
         * 
         * @type {string}
         * @memberof GTFSRoute
         */
        'route_url': string;
    }
    
        /**
     * 
     * @export
     * @interface GTFSService
     */
    export interface GTFSService {
        /**
         * 
         * @type {string}
         * @memberof GTFSService
         */
        'end_date': string;
        /**
         * 
         * @type {string}
         * @memberof GTFSService
         */
        'last_modify'?: string | null;
        /**
         * 
         * @type {number}
         * @memberof GTFSService
         */
        'monday': number;
        /**
         * 
         * @type {number}
         * @memberof GTFSService
         */
        'tuesday': number;
        /**
         * 
         * @type {number}
         * @memberof GTFSService
         */
        'wednesday': number;
        /**
         * 
         * @type {number}
         * @memberof GTFSService
         */
        'thursday': number;
        /**
         * 
         * @type {number}
         * @memberof GTFSService
         */
        'friday': number;
        /**
         * 
         * @type {number}
         * @memberof GTFSService
         */
        'saturday': number;
        /**
         * 
         * @type {number}
         * @memberof GTFSService
         */
        'sunday': number;
        /**
         * 
         * @type {string}
         * @memberof GTFSService
         */
        'service_id'?: string;
        /**
         * 
         * @type {string}
         * @memberof GTFSService
         */
        'start_date'?: string;
    }
    
        /**
     * 
     * @export
     * @interface GTFSShape
     */
    export interface GTFSShape {
        /**
         * 
         * @type {number}
         * @memberof GTFSShape
         */
        'shape_dist_traveled': number;
        /**
         * 
         * @type {string}
         * @memberof GTFSShape
         */
        'shape_id': string;
        /**
         * 
         * @type {number}
         * @memberof GTFSShape
         */
        'shape_pt_sequence': number;
    }
    
        /**
     * 
     * @export
     * @interface GTFSStop
     */
    export interface GTFSStop {
        /**
         * 
         * @type {number}
         * @memberof GTFSStop
         */
        'location_type': number;
        /**
         * 
         * @type {string}
         * @memberof GTFSStop
         */
        'parent_station': string | null;
        /**
         * 
         * @type {string}
         * @memberof GTFSStop
         */
        'platform_code': string;
        /**
         * 
         * @type {string}
         * @memberof GTFSStop
         */
        'stop_id': string;
        /**
         * 
         * @type {string}
         * @memberof GTFSStop
         */
        'stop_name': string;
        /**
         * 
         * @type {number}
         * @memberof GTFSStop
         */
        'wheelchair_boarding': number;
        /**
         * 
         * @type {string}
         * @memberof GTFSStop
         */
        'zone_id': string;
        /**
         * 
         * @type {string}
         * @memberof GTFSStop
         */
        'level_id': string | null;
    }
    
        /**
     * 
     * @export
     * @interface GTFSStopTime
     */
    export interface GTFSStopTime {
        /**
         * 
         * @type {string}
         * @memberof GTFSStopTime
         */
        'arrival_time': string;
        /**
         * 
         * @type {string}
         * @memberof GTFSStopTime
         */
        'departure_time': string;
        /**
         * 
         * @type {string}
         * @memberof GTFSStopTime
         */
        'drop_off_type': string;
        /**
         * 
         * @type {string}
         * @memberof GTFSStopTime
         */
        'last_modify'?: string | null;
        /**
         * 
         * @type {string}
         * @memberof GTFSStopTime
         */
        'pickup_type': string;
        /**
         * 
         * @type {number}
         * @memberof GTFSStopTime
         */
        'shape_dist_traveled': number;
        /**
         * 
         * @type {string}
         * @memberof GTFSStopTime
         */
        'stop_headsign'?: string;
        /**
         * 
         * @type {string}
         * @memberof GTFSStopTime
         */
        'stop_id': string;
        /**
         * 
         * @type {number}
         * @memberof GTFSStopTime
         */
        'stop_sequence': number;
        /**
         * 
         * @type {string}
         * @memberof GTFSStopTime
         */
        'trip_id': string;
    }
    
        /**
     * 
     * @export
     * @interface GTFSTrip
     */
    export interface GTFSTrip {
        /**
         * 
         * @type {string}
         * @memberof GTFSTrip
         */
        'trip_id': string;
        /**
         * 
         * @type {number}
         * @memberof GTFSTrip
         */
        'bikes_allowed': number;
        /**
         * 
         * @type {string}
         * @memberof GTFSTrip
         */
        'block_id'?: string | null;
        /**
         * 
         * @type {number}
         * @memberof GTFSTrip
         */
        'direction_id'?: number;
        /**
         * 
         * @type {number}
         * @memberof GTFSTrip
         */
        'exceptional'?: number;
        /**
         * 
         * @type {string}
         * @memberof GTFSTrip
         */
        'last_modify'?: string | null;
        /**
         * 
         * @type {string}
         * @memberof GTFSTrip
         */
        'route_id': string;
        /**
         * 
         * @type {string}
         * @memberof GTFSTrip
         */
        'service_id': string;
        /**
         * 
         * @type {string}
         * @memberof GTFSTrip
         */
        'shape_id': string;
        /**
         * 
         * @type {string}
         * @memberof GTFSTrip
         */
        'trip_headsign': string;
        /**
         * 
         * @type {number}
         * @memberof GTFSTrip
         */
        'wheelchair_accessible': number;
    }
    
        /**
     * GeoJson point
     * @export
     * @interface GeometryPoint
     */
    export interface GeometryPoint {
        /**
         * Point
         * @type {Array<number>}
         * @memberof GeometryPoint
         */
        'coordinates'?: Array<number>;
        /**
         * 
         * @type {string}
         * @memberof GeometryPoint
         */
        'type'?: GeometryPointTypeEnum;
    }
    
    export const GeometryPointTypeEnum = {
        Point: 'Point'
    } as const;
    
    export type GeometryPointTypeEnum = typeof GeometryPointTypeEnum[keyof typeof GeometryPointTypeEnum];
    
    
        /**
     * 
     * @export
     * @interface InformedEntityRoute
     */
    export interface InformedEntityRoute {
        /**
         * 
         * @type {string}
         * @memberof InformedEntityRoute
         */
        'id': string;
        /**
         * 
         * @type {string}
         * @memberof InformedEntityRoute
         */
        'route_short_name': string;
        /**
         * 
         * @type {string}
         * @memberof InformedEntityRoute
         */
        'route_long_name': string;
        /**
         * 
         * @type {RouteType}
         * @memberof InformedEntityRoute
         */
        'route_type': RouteType;
    }
    
    
    
        /**
     * 
     * @export
     * @interface InlineObject
     */
    export interface InlineObject {
        /**
         * 
         * @type {string}
         * @memberof InlineObject
         */
        'error_message': string;
        /**
         * 
         * @type {number}
         * @memberof InlineObject
         */
        'error_status': number;
    }
    
        /**
     * 
     * @export
     * @interface PIDDepartureBoard
     */
    export interface PIDDepartureBoard {
        /**
         * List of stops in the requested set and their properties.
         * @type {Array<PIDDepartureBoardStop>}
         * @memberof PIDDepartureBoard
         */
        'stops'?: Array<PIDDepartureBoardStop>;
        /**
         * List of departures.
         * @type {Array<PIDDepartureBoardDeparture>}
         * @memberof PIDDepartureBoard
         */
        'departures'?: Array<PIDDepartureBoardDeparture>;
        /**
         * List of active infotexts for selected stops.
         * @type {Array<PIDDepartureBoardInfotextsInner>}
         * @memberof PIDDepartureBoard
         */
        'infotexts'?: Array<PIDDepartureBoardInfotextsInner>;
    }
    
        /**
     * 
     * @export
     * @interface PIDDepartureBoardDelay
     */
    export interface PIDDepartureBoardDelay {
        /**
         * True if information about trip\'s delay is available.
         * @type {boolean}
         * @memberof PIDDepartureBoardDelay
         */
        'is_available': boolean;
        /**
         * Delay rounded down to minutes.
         * @type {number}
         * @memberof PIDDepartureBoardDelay
         */
        'minutes': number | null;
        /**
         * Delay in seconds.
         * @type {number}
         * @memberof PIDDepartureBoardDelay
         */
        'seconds': number | null;
    }
    
        /**
     * 
     * @export
     * @interface PIDDepartureBoardDeparture
     */
    export interface PIDDepartureBoardDeparture {
        /**
         * 
         * @type {PIDDepartureBoardStopTime}
         * @memberof PIDDepartureBoardDeparture
         */
        'arrival_timestamp'?: PIDDepartureBoardStopTime;
        /**
         * 
         * @type {PIDDepartureBoardDelay}
         * @memberof PIDDepartureBoardDeparture
         */
        'delay'?: PIDDepartureBoardDelay;
        /**
         * 
         * @type {PIDDepartureBoardStopTime}
         * @memberof PIDDepartureBoardDeparture
         */
        'departure_timestamp'?: PIDDepartureBoardStopTime;
        /**
         * 
         * @type {PIDDepartureBoardLastStop}
         * @memberof PIDDepartureBoardDeparture
         */
        'last_stop'?: PIDDepartureBoardLastStop;
        /**
         * 
         * @type {PIDDepartureBoardRoute}
         * @memberof PIDDepartureBoardDeparture
         */
        'route'?: PIDDepartureBoardRoute;
        /**
         * 
         * @type {PIDDepartureBoardStopReference}
         * @memberof PIDDepartureBoardDeparture
         */
        'stop'?: PIDDepartureBoardStopReference;
        /**
         * 
         * @type {PIDDepartureBoardTrip}
         * @memberof PIDDepartureBoardDeparture
         */
        'trip'?: PIDDepartureBoardTrip;
    }
    
        /**
     * 
     * @export
     * @interface PIDDepartureBoardInfotext
     */
    export interface PIDDepartureBoardInfotext {
        /**
         * Intended time of infotext publishing in ISO String.
         * @type {string}
         * @memberof PIDDepartureBoardInfotext
         */
        'valid_from': string | null;
        /**
         * Intended time of infotext removal in ISO String. If `null`, the infotext is valid indefinitely
         * @type {string}
         * @memberof PIDDepartureBoardInfotext
         */
        'valid_to': string | null;
        /**
         * Information text in Czech.
         * @type {string}
         * @memberof PIDDepartureBoardInfotext
         */
        'text': string;
        /**
         * Information text in English.
         * @type {string}
         * @memberof PIDDepartureBoardInfotext
         */
        'text_en': string | null;
        /**
         * Type of display on board by the intended form of presentation (where applicable). Enumerating `inline` (to be presented along with departures, usually in a marquee), `general` (to be displayed full screen instead of departures).
         * @type {string}
         * @memberof PIDDepartureBoardInfotext
         */
        'display_type': PIDDepartureBoardInfotextDisplayTypeEnum;
    }
    
    export const PIDDepartureBoardInfotextDisplayTypeEnum = {
        Inline: 'inline',
        General: 'general'
    } as const;
    
    export type PIDDepartureBoardInfotextDisplayTypeEnum = typeof PIDDepartureBoardInfotextDisplayTypeEnum[keyof typeof PIDDepartureBoardInfotextDisplayTypeEnum];
    
    
        /**
     * 
     * @export
     * @interface PIDDepartureBoardInfotextsInner
     */
    export interface PIDDepartureBoardInfotextsInner {
        /**
         * Intended time of infotext publishing in ISO String.
         * @type {string}
         * @memberof PIDDepartureBoardInfotextsInner
         */
        'valid_from': string | null;
        /**
         * Intended time of infotext removal in ISO String. If `null`, the infotext is valid indefinitely
         * @type {string}
         * @memberof PIDDepartureBoardInfotextsInner
         */
        'valid_to': string | null;
        /**
         * Information text in Czech.
         * @type {string}
         * @memberof PIDDepartureBoardInfotextsInner
         */
        'text': string;
        /**
         * Information text in English.
         * @type {string}
         * @memberof PIDDepartureBoardInfotextsInner
         */
        'text_en': string | null;
        /**
         * Type of display on board by the intended form of presentation (where applicable). Enumerating `inline` (to be presented along with departures, usually in a marquee), `general` (to be displayed full screen instead of departures).
         * @type {string}
         * @memberof PIDDepartureBoardInfotextsInner
         */
        'display_type': PIDDepartureBoardInfotextsInnerDisplayTypeEnum;
        /**
         * 
         * @type {Array<string>}
         * @memberof PIDDepartureBoardInfotextsInner
         */
        'related_stops'?: Array<string>;
    }
    
    export const PIDDepartureBoardInfotextsInnerDisplayTypeEnum = {
        Inline: 'inline',
        General: 'general'
    } as const;
    
    export type PIDDepartureBoardInfotextsInnerDisplayTypeEnum = typeof PIDDepartureBoardInfotextsInnerDisplayTypeEnum[keyof typeof PIDDepartureBoardInfotextsInnerDisplayTypeEnum];
    
    
        /**
     * 
     * @export
     * @interface PIDDepartureBoardLastStop
     */
    export interface PIDDepartureBoardLastStop {
        /**
         * Name of the last stop the vehicle reported from.
         * @type {string}
         * @memberof PIDDepartureBoardLastStop
         */
        'name': string | null;
        /**
         * GTFS ID of the stop.
         * @type {string}
         * @memberof PIDDepartureBoardLastStop
         */
        'id': string | null;
    }
    
        /**
     * 
     * @export
     * @interface PIDDepartureBoardRoute
     */
    export interface PIDDepartureBoardRoute {
        /**
         * Route designation used by PID.
         * @type {string}
         * @memberof PIDDepartureBoardRoute
         */
        'short_name': string | null;
        /**
         * GTFS route type. `0` ‚Äì tram, `1` ‚Äì metro, `2` ‚Äì train, `3` ‚Äì bus, `4` ‚Äì ferry, `7` ‚Äì funicular, `11` ‚Äì trolleybus
         * @type {number}
         * @memberof PIDDepartureBoardRoute
         */
        'type': number | null;
        /**
         * True if route is a designated night route.
         * @type {boolean}
         * @memberof PIDDepartureBoardRoute
         */
        'is_night': boolean;
        /**
         * True if route serves areas outside Prague boundaries.
         * @type {boolean}
         * @memberof PIDDepartureBoardRoute
         */
        'is_regional': boolean;
        /**
         * True if route provides substitute service for another route.
         * @type {boolean}
         * @memberof PIDDepartureBoardRoute
         */
        'is_substitute_transport': boolean;
    }
    
        /**
     * 
     * @export
     * @interface PIDDepartureBoardStop
     */
    export interface PIDDepartureBoardStop {
        /**
         * Level of metro stops.
         * @type {string}
         * @memberof PIDDepartureBoardStop
         */
        'level_id': string | null;
        /**
         * Describes the type of stop, is always `0`.
         * @type {number}
         * @memberof PIDDepartureBoardStop
         */
        'location_type': number;
        /**
         * A GTFS identifier of the parent station for metro platforms.
         * @type {string}
         * @memberof PIDDepartureBoardStop
         */
        'parent_station': string;
        /**
         * Human-friendly code used to distinguish a stop inside a node. Multiple GTFS codes can share a platform code.
         * @type {string}
         * @memberof PIDDepartureBoardStop
         */
        'platform_code': string;
        /**
         * Latitude of the stop marker or the center of metro or train station platform.
         * @type {number}
         * @memberof PIDDepartureBoardStop
         */
        'stop_lat': number;
        /**
         * Longitude of the stop marker or the center of metro or train station platform.
         * @type {number}
         * @memberof PIDDepartureBoardStop
         */
        'stop_lon': number;
        /**
         * 
         * @type {ASWid}
         * @memberof PIDDepartureBoardStop
         */
        'asw_id': ASWid;
        /**
         * GTFS ID of the stop. Stops that will be valid in the future have the date of the start of their validity appended, i.e. `U476Z51P_210401`.
         * @type {string}
         * @memberof PIDDepartureBoardStop
         */
        'stop_id': string;
        /**
         * Name of the stop.
         * @type {string}
         * @memberof PIDDepartureBoardStop
         */
        'stop_name': string;
        /**
         * Indicates accessibility of the stop by wheelchairs. `0` ‚Äì unknown, `1` ‚Äì accessible, `2` ‚Äì inaccessible
         * @type {number}
         * @memberof PIDDepartureBoardStop
         */
        'wheelchair_boarding': number;
        /**
         * PID fare zone. Multiple zones are separated by a comma.
         * @type {string}
         * @memberof PIDDepartureBoardStop
         */
        'zone_id': string;
    }
    
        /**
     * 
     * @export
     * @interface PIDDepartureBoardStopReference
     */
    export interface PIDDepartureBoardStopReference {
        /**
         * GTFS ID of the stop the vehicle is stopping at.
         * @type {string}
         * @memberof PIDDepartureBoardStopReference
         */
        'id': string;
        /**
         * For trains it is the platform number the train is stopping at. Is `null` if not known. For other modes of transport, returns the platform code from `stops[]`.
         * @type {string}
         * @memberof PIDDepartureBoardStopReference
         */
        'platform_code': string | null;
    }
    
        /**
     * 
     * @export
     * @interface PIDDepartureBoardStopTime
     */
    export interface PIDDepartureBoardStopTime {
        /**
         * Time of arrival/departure including realtime delay as an ISO String (UTC). Is `null` on start/end stops. Is same as scheduled time when no delay is available. Is `null` on first/last stops.
         * @type {string}
         * @memberof PIDDepartureBoardStopTime
         */
        'predicted': string;
        /**
         * Time of arrival/departure as ISO string (UTC).
         * @type {string}
         * @memberof PIDDepartureBoardStopTime
         */
        'scheduled': string;
        /**
         * Number of minutes till departure. If it is less than 30 second it returns value \"<1\".
         * @type {string}
         * @memberof PIDDepartureBoardStopTime
         */
        'minutes'?: string;
    }
    
        /**
     * 
     * @export
     * @interface PIDDepartureBoardTrip
     */
    export interface PIDDepartureBoardTrip {
        /**
         * The equivalent of arrows that are printed on stop signs. Indicates the direction the vehicle will continue at stops where routes split up relative to the direction of motion of the vehicle. Valid values: `null` (do not display the arrow), `top`, `top-right`, `right`, `bottom-right`, `bottom`, `bottom-left`, `left`, `top-left`.
         * @type {string}
         * @memberof PIDDepartureBoardTrip
         */
        'direction': string | null;
        /**
         * Trip headsign (usually the final stop).
         * @type {string}
         * @memberof PIDDepartureBoardTrip
         */
        'headsign': string;
        /**
         * GTFS trip ID.
         * @type {string}
         * @memberof PIDDepartureBoardTrip
         */
        'id': string;
        /**
         * True if vehicle is physically present in the stop. Applicable only to connections with delay available.
         * @type {boolean}
         * @memberof PIDDepartureBoardTrip
         */
        'is_at_stop': boolean;
        /**
         * True if the trip is canceled.
         * @type {boolean}
         * @memberof PIDDepartureBoardTrip
         */
        'is_canceled': boolean;
        /**
         * True if the vehicle being used on this trip is wheelchair accessible. Metro trips are deemed accessible if the station is accessible.
         * @type {boolean}
         * @memberof PIDDepartureBoardTrip
         */
        'is_wheelchair_accessible': boolean;
        /**
         * Determines whether the vehicle has air conditioning. If `null`, the information is not available or the vehicle\'s registration number is not known.
         * @type {boolean}
         * @memberof PIDDepartureBoardTrip
         */
        'is_air_conditioned': boolean | null;
        /**
         * The number of a particular train, otherwise `null`.
         * @type {string}
         * @memberof PIDDepartureBoardTrip
         */
        'short_name': string | null;
    }
    
        /**
     * 
     * @export
     * @interface PublicDeparture
     */
    export interface PublicDeparture {
        /**
         * 
         * @type {string}
         * @memberof PublicDeparture
         */
        'timestamp_scheduled': string;
        /**
         * 
         * @type {string}
         * @memberof PublicDeparture
         */
        'timestamp_predicted': string;
        /**
         * Delay in seconds
         * @type {number}
         * @memberof PublicDeparture
         */
        'delay_seconds'?: number | null;
        /**
         * Minutes until the departure
         * @type {number}
         * @memberof PublicDeparture
         */
        'minutes': number;
    }
    
        /**
     * 
     * @export
     * @interface PublicDepartureGroupInner
     */
    export interface PublicDepartureGroupInner {
        /**
         * 
         * @type {PublicDeparture}
         * @memberof PublicDepartureGroupInner
         */
        'departure': PublicDeparture;
        /**
         * 
         * @type {PublicDepartureStop}
         * @memberof PublicDepartureGroupInner
         */
        'stop': PublicDepartureStop;
        /**
         * 
         * @type {PublicDepartureRoute}
         * @memberof PublicDepartureGroupInner
         */
        'route': PublicDepartureRoute;
        /**
         * 
         * @type {PublicDepartureTrip}
         * @memberof PublicDepartureGroupInner
         */
        'trip': PublicDepartureTrip;
        /**
         * 
         * @type {PublicDepartureVehicle}
         * @memberof PublicDepartureGroupInner
         */
        'vehicle': PublicDepartureVehicle;
    }
    
        /**
     * 
     * @export
     * @interface PublicDepartureRoute
     */
    export interface PublicDepartureRoute {
        /**
         * 
         * @type {string}
         * @memberof PublicDepartureRoute
         */
        'type': PublicDepartureRouteTypeEnum;
        /**
         * 
         * @type {string}
         * @memberof PublicDepartureRoute
         */
        'short_name': string;
    }
    
    export const PublicDepartureRouteTypeEnum = {
        Tram: 'tram',
        Metro: 'metro',
        Train: 'train',
        Bus: 'bus',
        Ferry: 'ferry',
        Funicular: 'funicular',
        Trolleybus: 'trolleybus',
        ExtMiscellaneous: 'ext_miscellaneous'
    } as const;
    
    export type PublicDepartureRouteTypeEnum = typeof PublicDepartureRouteTypeEnum[keyof typeof PublicDepartureRouteTypeEnum];
    
    
        /**
     * 
     * @export
     * @interface PublicDepartureStop
     */
    export interface PublicDepartureStop {
        /**
         * 
         * @type {string}
         * @memberof PublicDepartureStop
         */
        'id': string;
        /**
         * 
         * @type {number}
         * @memberof PublicDepartureStop
         */
        'sequence': number;
        /**
         * 
         * @type {string}
         * @memberof PublicDepartureStop
         */
        'platform_code'?: string | null;
    }
    
        /**
     * 
     * @export
     * @interface PublicDepartureTrip
     */
    export interface PublicDepartureTrip {
        /**
         * 
         * @type {string}
         * @memberof PublicDepartureTrip
         */
        'id': string;
        /**
         * 
         * @type {string}
         * @memberof PublicDepartureTrip
         */
        'headsign': string;
        /**
         * 
         * @type {boolean}
         * @memberof PublicDepartureTrip
         */
        'is_canceled'?: boolean | null;
    }
    
        /**
     * 
     * @export
     * @interface PublicDepartureVehicle
     */
    export interface PublicDepartureVehicle {
        /**
         * 
         * @type {string}
         * @memberof PublicDepartureVehicle
         */
        'id'?: string | null;
        /**
         * 
         * @type {boolean}
         * @memberof PublicDepartureVehicle
         */
        'is_wheelchair_accessible'?: boolean | null;
        /**
         * 
         * @type {boolean}
         * @memberof PublicDepartureVehicle
         */
        'is_air_conditioned'?: boolean | null;
        /**
         * 
         * @type {boolean}
         * @memberof PublicDepartureVehicle
         */
        'has_charger'?: boolean | null;
    }
    
        /**
     * 
     * @export
     * @interface PublicTripShapeFeatureCollection
     */
    export interface PublicTripShapeFeatureCollection {
        /**
         * 
         * @type {Array<PublicTripShapeFeatureCollectionFeaturesInner>}
         * @memberof PublicTripShapeFeatureCollection
         */
        'features'?: Array<PublicTripShapeFeatureCollectionFeaturesInner>;
        /**
         * 
         * @type {string}
         * @memberof PublicTripShapeFeatureCollection
         */
        'type'?: string;
    }
    
        /**
     * 
     * @export
     * @interface PublicTripShapeFeatureCollectionFeaturesInner
     */
    export interface PublicTripShapeFeatureCollectionFeaturesInner {
        /**
         * 
         * @type {GeometryPoint}
         * @memberof PublicTripShapeFeatureCollectionFeaturesInner
         */
        'geometry'?: GeometryPoint;
        /**
         * 
         * @type {PublicTripShapeFeatureCollectionFeaturesInnerProperties}
         * @memberof PublicTripShapeFeatureCollectionFeaturesInner
         */
        'properties'?: PublicTripShapeFeatureCollectionFeaturesInnerProperties;
        /**
         * 
         * @type {string}
         * @memberof PublicTripShapeFeatureCollectionFeaturesInner
         */
        'type'?: string;
    }
    
        /**
     * 
     * @export
     * @interface PublicTripShapeFeatureCollectionFeaturesInnerProperties
     */
    export interface PublicTripShapeFeatureCollectionFeaturesInnerProperties {
        /**
         * Distance from the first stop of the trip.
         * @type {number}
         * @memberof PublicTripShapeFeatureCollectionFeaturesInnerProperties
         */
        'shape_dist_traveled'?: number;
    }
    
        /**
     * List of stop and arrival, departure times for the trip. No stop waypoints are not included.
     * @export
     * @interface PublicTripStaticStopTimeFeatureCollection
     */
    export interface PublicTripStaticStopTimeFeatureCollection {
        /**
         * 
         * @type {Array<PublicTripStaticStopTimeFeatureCollectionFeaturesInner>}
         * @memberof PublicTripStaticStopTimeFeatureCollection
         */
        'features'?: Array<PublicTripStaticStopTimeFeatureCollectionFeaturesInner>;
        /**
         * 
         * @type {string}
         * @memberof PublicTripStaticStopTimeFeatureCollection
         */
        'type'?: string;
    }
    
        /**
     * 
     * @export
     * @interface PublicTripStaticStopTimeFeatureCollectionFeaturesInner
     */
    export interface PublicTripStaticStopTimeFeatureCollectionFeaturesInner {
        /**
         * 
         * @type {GeometryPoint}
         * @memberof PublicTripStaticStopTimeFeatureCollectionFeaturesInner
         */
        'geometry'?: GeometryPoint;
        /**
         * 
         * @type {PublicTripStaticStopTimeFeatureCollectionFeaturesInnerProperties}
         * @memberof PublicTripStaticStopTimeFeatureCollectionFeaturesInner
         */
        'properties'?: PublicTripStaticStopTimeFeatureCollectionFeaturesInnerProperties;
        /**
         * 
         * @type {string}
         * @memberof PublicTripStaticStopTimeFeatureCollectionFeaturesInner
         */
        'type'?: string;
    }
    
        /**
     * 
     * @export
     * @interface PublicTripStaticStopTimeFeatureCollectionFeaturesInnerProperties
     */
    export interface PublicTripStaticStopTimeFeatureCollectionFeaturesInnerProperties {
        /**
         * 
         * @type {string}
         * @memberof PublicTripStaticStopTimeFeatureCollectionFeaturesInnerProperties
         */
        'stop_name'?: string;
        /**
         * 
         * @type {number}
         * @memberof PublicTripStaticStopTimeFeatureCollectionFeaturesInnerProperties
         */
        'stop_sequence'?: number;
        /**
         * 
         * @type {string}
         * @memberof PublicTripStaticStopTimeFeatureCollectionFeaturesInnerProperties
         */
        'zone_id'?: string | null;
        /**
         * 
         * @type {boolean}
         * @memberof PublicTripStaticStopTimeFeatureCollectionFeaturesInnerProperties
         */
        'is_wheelchair_accessible'?: boolean | null;
        /**
         * 
         * @type {number}
         * @memberof PublicTripStaticStopTimeFeatureCollectionFeaturesInnerProperties
         */
        'shape_dist_traveled'?: number;
        /**
         * Time for arrival to the stop according to trip schedule.
         * @type {string}
         * @memberof PublicTripStaticStopTimeFeatureCollectionFeaturesInnerProperties
         */
        'arrival_time'?: string;
        /**
         * Time for departure from the stop according to trip schedule.
         * @type {string}
         * @memberof PublicTripStaticStopTimeFeatureCollectionFeaturesInnerProperties
         */
        'departure_time'?: string;
    }
    
        /**
     * List of stop and arrival, departure times for the trip.
     * @export
     * @interface PublicTripStopTimeFeatureCollection
     */
    export interface PublicTripStopTimeFeatureCollection {
        /**
         * 
         * @type {Array<PublicTripStopTimeFeatureCollectionFeaturesInner>}
         * @memberof PublicTripStopTimeFeatureCollection
         */
        'features'?: Array<PublicTripStopTimeFeatureCollectionFeaturesInner>;
        /**
         * 
         * @type {string}
         * @memberof PublicTripStopTimeFeatureCollection
         */
        'type'?: string;
    }
    
        /**
     * 
     * @export
     * @interface PublicTripStopTimeFeatureCollectionFeaturesInner
     */
    export interface PublicTripStopTimeFeatureCollectionFeaturesInner {
        /**
         * 
         * @type {GeometryPoint}
         * @memberof PublicTripStopTimeFeatureCollectionFeaturesInner
         */
        'geometry'?: GeometryPoint;
        /**
         * 
         * @type {PublicTripStopTimeFeatureCollectionFeaturesInnerProperties}
         * @memberof PublicTripStopTimeFeatureCollectionFeaturesInner
         */
        'properties'?: PublicTripStopTimeFeatureCollectionFeaturesInnerProperties;
        /**
         * 
         * @type {string}
         * @memberof PublicTripStopTimeFeatureCollectionFeaturesInner
         */
        'type'?: string;
    }
    
        /**
     * 
     * @export
     * @interface PublicTripStopTimeFeatureCollectionFeaturesInnerProperties
     */
    export interface PublicTripStopTimeFeatureCollectionFeaturesInnerProperties {
        /**
         * 
         * @type {string}
         * @memberof PublicTripStopTimeFeatureCollectionFeaturesInnerProperties
         */
        'stop_name'?: string;
        /**
         * 
         * @type {number}
         * @memberof PublicTripStopTimeFeatureCollectionFeaturesInnerProperties
         */
        'stop_sequence'?: number;
        /**
         * 
         * @type {string}
         * @memberof PublicTripStopTimeFeatureCollectionFeaturesInnerProperties
         */
        'zone_id'?: string | null;
        /**
         * 
         * @type {boolean}
         * @memberof PublicTripStopTimeFeatureCollectionFeaturesInnerProperties
         */
        'is_wheelchair_accessible'?: boolean | null;
        /**
         * 
         * @type {number}
         * @memberof PublicTripStopTimeFeatureCollectionFeaturesInnerProperties
         */
        'shape_dist_traveled'?: number;
        /**
         * Time for arrival to the stop according to trip schedule.
         * @type {string}
         * @memberof PublicTripStopTimeFeatureCollectionFeaturesInnerProperties
         */
        'arrival_time'?: string;
        /**
         * Time for departure from the stop according to trip schedule.
         * @type {string}
         * @memberof PublicTripStopTimeFeatureCollectionFeaturesInnerProperties
         */
        'departure_time'?: string;
        /**
         * Time for arrival to the stop according to realtime data or prediction based on current delay.
         * @type {string}
         * @memberof PublicTripStopTimeFeatureCollectionFeaturesInnerProperties
         */
        'realtime_arrival_time'?: string | null;
        /**
         * Time for departure from the stop according to realtime data or prediction based on current delay.
         * @type {string}
         * @memberof PublicTripStopTimeFeatureCollectionFeaturesInnerProperties
         */
        'realtime_departure_time'?: string | null;
    }
    
        /**
     * 0 - tram \\ 1 - metro \\ 2 - rail \\ 3 - bus \\ 4 - ferry \\ 7 - funicular \\ 11 - trolleybus 
     * @export
     * @enum {number}
     */
    
    export const RouteType = {
        NUMBER_0: 0,
        NUMBER_1: 1,
        NUMBER_2: 2,
        NUMBER_3: 3,
        NUMBER_4: 4,
        NUMBER_7: 7,
        NUMBER_11: 11
    } as const;
    
    export type RouteType = typeof RouteType[keyof typeof RouteType];
    
    
        /**
     * 
     * @export
     * @interface ScopeInfo
     */
    export interface ScopeInfo {
        /**
         * 
         * @type {string}
         * @memberof ScopeInfo
         */
        'gtfs_trip_id'?: string;
        /**
         * 
         * @type {string}
         * @memberof ScopeInfo
         */
        'route_type'?: ScopeInfoRouteTypeEnum;
        /**
         * 
         * @type {string}
         * @memberof ScopeInfo
         */
        'route_short_name'?: string;
        /**
         * 
         * @type {string}
         * @memberof ScopeInfo
         */
        'shape_id'?: string | null;
        /**
         * 
         * @type {string}
         * @memberof ScopeInfo
         */
        'origin_route_name'?: string | null;
        /**
         * 
         * @type {number}
         * @memberof ScopeInfo
         */
        'run_number'?: number | null;
        /**
         * 
         * @type {string}
         * @memberof ScopeInfo
         */
        'trip_headsign'?: string | null;
        /**
         * 
         * @type {GeometryPoint}
         * @memberof ScopeInfo
         */
        'geometry'?: GeometryPoint;
        /**
         * Distance travelled from the first stop of the trip.
         * @type {number}
         * @memberof ScopeInfo
         */
        'shape_dist_traveled'?: number | null;
        /**
         * Bearing of the vehicle in degrees (0-360).
         * @type {number}
         * @memberof ScopeInfo
         */
        'bearing'?: number | null;
        /**
         * Delay of the vehicle in seconds.
         * @type {number}
         * @memberof ScopeInfo
         */
        'delay'?: number | null;
        /**
         * 
         * @type {StatePosition}
         * @memberof ScopeInfo
         */
        'state_position'?: StatePosition;
        /**
         * index of last stop passed by the vehicle
         * @type {number}
         * @memberof ScopeInfo
         */
        'last_stop_sequence'?: number | null;
        /**
         * time when vehicle send last update
         * @type {string}
         * @memberof ScopeInfo
         */
        'origin_timestamp'?: string | null;
    }
    
    export const ScopeInfoRouteTypeEnum = {
        Tram: 'tram',
        Metro: 'metro',
        Train: 'train',
        Bus: 'bus',
        Ferry: 'ferry',
        Funicular: 'funicular',
        Trolleybus: 'trolleybus',
        ExtMiscellaneous: 'ext_miscellaneous'
    } as const;
    
    export type ScopeInfoRouteTypeEnum = typeof ScopeInfoRouteTypeEnum[keyof typeof ScopeInfoRouteTypeEnum];
    
    
        /**
     * 
     * @export
     * @interface ScopeShapes
     */
    export interface ScopeShapes {
        /**
         * 
         * @type {PublicTripShapeFeatureCollection}
         * @memberof ScopeShapes
         */
        'shapes'?: PublicTripShapeFeatureCollection;
    }
    
        /**
     * 
     * @export
     * @interface ScopeStaticInfo
     */
    export interface ScopeStaticInfo {
        /**
         * 
         * @type {string}
         * @memberof ScopeStaticInfo
         */
        'gtfs_trip_id'?: string;
        /**
         * 
         * @type {string}
         * @memberof ScopeStaticInfo
         */
        'route_type'?: ScopeStaticInfoRouteTypeEnum;
        /**
         * 
         * @type {string}
         * @memberof ScopeStaticInfo
         */
        'route_short_name'?: string;
        /**
         * 
         * @type {string}
         * @memberof ScopeStaticInfo
         */
        'shape_id'?: string | null;
        /**
         * 
         * @type {string}
         * @memberof ScopeStaticInfo
         */
        'origin_route_name'?: string | null;
        /**
         * 
         * @type {number}
         * @memberof ScopeStaticInfo
         */
        'run_number'?: number | null;
        /**
         * 
         * @type {string}
         * @memberof ScopeStaticInfo
         */
        'trip_headsign'?: string | null;
    }
    
    export const ScopeStaticInfoRouteTypeEnum = {
        Tram: 'tram',
        Metro: 'metro',
        Train: 'train',
        Bus: 'bus',
        Ferry: 'ferry',
        Funicular: 'funicular',
        Trolleybus: 'trolleybus',
        ExtMiscellaneous: 'ext_miscellaneous'
    } as const;
    
    export type ScopeStaticInfoRouteTypeEnum = typeof ScopeStaticInfoRouteTypeEnum[keyof typeof ScopeStaticInfoRouteTypeEnum];
    
    
        /**
     * 
     * @export
     * @interface ScopeStaticStopTimes
     */
    export interface ScopeStaticStopTimes {
        /**
         * 
         * @type {PublicTripStaticStopTimeFeatureCollection}
         * @memberof ScopeStaticStopTimes
         */
        'stop_times'?: PublicTripStaticStopTimeFeatureCollection;
    }
    
        /**
     * 
     * @export
     * @interface ScopeStaticVehicleDescriptor
     */
    export interface ScopeStaticVehicleDescriptor {
        /**
         * 
         * @type {ScopeStaticVehicleDescriptorVehicleDescriptor}
         * @memberof ScopeStaticVehicleDescriptor
         */
        'vehicle_descriptor'?: ScopeStaticVehicleDescriptorVehicleDescriptor;
    }
    
        /**
     * 
     * @export
     * @interface ScopeStaticVehicleDescriptorVehicleDescriptor
     */
    export interface ScopeStaticVehicleDescriptorVehicleDescriptor {
        /**
         * 
         * @type {boolean}
         * @memberof ScopeStaticVehicleDescriptorVehicleDescriptor
         */
        'is_wheelchair_accessible'?: boolean | null;
    }
    
        /**
     * 
     * @export
     * @interface ScopeStopTimes
     */
    export interface ScopeStopTimes {
        /**
         * 
         * @type {PublicTripStopTimeFeatureCollection}
         * @memberof ScopeStopTimes
         */
        'stop_times'?: PublicTripStopTimeFeatureCollection;
    }
    
        /**
     * 
     * @export
     * @interface ScopeVehicleDescriptor
     */
    export interface ScopeVehicleDescriptor {
        /**
         * 
         * @type {ScopeVehicleDescriptorVehicleDescriptor}
         * @memberof ScopeVehicleDescriptor
         */
        'vehicle_descriptor'?: ScopeVehicleDescriptorVehicleDescriptor;
    }
    
        /**
     * 
     * @export
     * @interface ScopeVehicleDescriptorVehicleDescriptor
     */
    export interface ScopeVehicleDescriptorVehicleDescriptor {
        /**
         * 
         * @type {string}
         * @memberof ScopeVehicleDescriptorVehicleDescriptor
         */
        'operator'?: string | null;
        /**
         * Vehicle manufacturer and type (model)
         * @type {string}
         * @memberof ScopeVehicleDescriptorVehicleDescriptor
         */
        'vehicle_type'?: string | null;
        /**
         * 
         * @type {boolean}
         * @memberof ScopeVehicleDescriptorVehicleDescriptor
         */
        'is_wheelchair_accessible'?: boolean | null;
        /**
         * 
         * @type {boolean}
         * @memberof ScopeVehicleDescriptorVehicleDescriptor
         */
        'is_air_conditioned'?: boolean | null;
        /**
         * 
         * @type {boolean}
         * @memberof ScopeVehicleDescriptorVehicleDescriptor
         */
        'has_usb_chargers'?: boolean | null;
        /**
         * 
         * @type {string}
         * @memberof ScopeVehicleDescriptorVehicleDescriptor
         */
        'vehicle_registration_number'?: string | null;
    }
    
        /**
     * - `at_stop` - The position is tracking and the closest anchor point or metro rail track segment is a stop. - `before_track` - The position is not tracking and either the trip\'s previous position is not known, or the previous position\'s state is `at_stop` or `on_track`. - `before_track_delayed` - The position has a delay prediction based on the vehicle\'s previous trip. - `canceled` - The position is canceled. - `off_track` - The position is tracking and the vehicle is 200+ meters from the closest anchor point or metro rail track segment of its track. For metro positions, it is additionally required that the vehicle\'s message attributes `tm` and `odch` or less than or equal to the arrival to the final stop. - `on_track` - The position is tracking, but is neither `at_stop` nor `off_track`.  The following states also exist internally but are excluded from the API output: - `after_track` - The position is not tracking and the trip\'s last known position is tracking. For metro positions, this can also mean that it is tracking, the vehicle is 200+ meters from the closest metro rail track segment of its track and the vehicle\'s message attributes `tm` and `odch` or higher than the arrival to the final stop. For other positions from TCP sources (DPP buses and trams), this can also mean that it is tracking and the vehicle sent a message while at the final stop or sent a message with the `tjr` attribute higher than the arrival to the final stop. - `after_track_delayed` - The same as `after_track`, but the position always has defined delay (not null) if possible to deduct from GTFS static data and origin timestamp. Essentially, it means the vehicle is `at_stop` at the very last stop of the trip. The delay is also propagated to the next trip of the vehicle, unlike the `after_track` state. - `duplicate` - The position is not tracking, the trip\'s last known position is tracking and there is another position with identical `origin_timestamp`. - `invisible` - The position is not tracking and either:     - the trip\'s previous position is not known or the previous position\'s state is `at_stop` or `on_track`, and the vehicle is on its way from the garage;     - or the trip\'s last known position is tracking and the vehicle is on its way to the garage. - `mismatched` - The position does not make sense (e.g. it was sent late and thus has a mismatched stop sequence). - `not_public` - The position belongs to a non-public trip (trip without run schedule). - `unknown` - The position is not yet processed (or was determined to never be processed) or has been invalidated (e.g. due to a vehicle repeating some part of the trip). 
     * @export
     * @enum {string}
     */
    
    export const StatePosition = {
        AtStop: 'at_stop',
        BeforeTrack: 'before_track',
        BeforeTrackDelayed: 'before_track_delayed',
        Canceled: 'canceled',
        OffTrack: 'off_track',
        OnTrack: 'on_track'
    } as const;
    
    export type StatePosition = typeof StatePosition[keyof typeof StatePosition];
    
    
        /**
     * 
     * @export
     * @interface V2GtfsShapesIdGet200Response
     */
    export interface V2GtfsShapesIdGet200Response {
        /**
         * 
         * @type {string}
         * @memberof V2GtfsShapesIdGet200Response
         */
        'type'?: string;
        /**
         * 
         * @type {Array<V2GtfsTripsIdGet200ResponseAllOfShapesInner>}
         * @memberof V2GtfsShapesIdGet200Response
         */
        'features'?: Array<V2GtfsTripsIdGet200ResponseAllOfShapesInner>;
    }
    
        /**
     * 
     * @export
     * @interface V2GtfsStopsGet200Response
     */
    export interface V2GtfsStopsGet200Response {
        /**
         * 
         * @type {string}
         * @memberof V2GtfsStopsGet200Response
         */
        'type'?: string;
        /**
         * 
         * @type {Array<V2GtfsStopsGet200ResponseFeaturesInner>}
         * @memberof V2GtfsStopsGet200Response
         */
        'features'?: Array<V2GtfsStopsGet200ResponseFeaturesInner>;
    }
    
        /**
     * 
     * @export
     * @interface V2GtfsStopsGet200ResponseFeaturesInner
     */
    export interface V2GtfsStopsGet200ResponseFeaturesInner {
        /**
         * 
         * @type {FeaturePointGeometry}
         * @memberof V2GtfsStopsGet200ResponseFeaturesInner
         */
        'geometry': FeaturePointGeometry;
        /**
         * 
         * @type {GTFSStop}
         * @memberof V2GtfsStopsGet200ResponseFeaturesInner
         */
        'properties': GTFSStop;
        /**
         * 
         * @type {string}
         * @memberof V2GtfsStopsGet200ResponseFeaturesInner
         */
        'type': string;
    }
    
        /**
     * 
     * @export
     * @interface V2GtfsTripsIdGet200Response
     */
    export interface V2GtfsTripsIdGet200Response {
        /**
         * 
         * @type {string}
         * @memberof V2GtfsTripsIdGet200Response
         */
        'trip_id': string;
        /**
         * 
         * @type {number}
         * @memberof V2GtfsTripsIdGet200Response
         */
        'bikes_allowed': number;
        /**
         * 
         * @type {string}
         * @memberof V2GtfsTripsIdGet200Response
         */
        'block_id'?: string | null;
        /**
         * 
         * @type {number}
         * @memberof V2GtfsTripsIdGet200Response
         */
        'direction_id'?: number;
        /**
         * 
         * @type {number}
         * @memberof V2GtfsTripsIdGet200Response
         */
        'exceptional'?: number;
        /**
         * 
         * @type {string}
         * @memberof V2GtfsTripsIdGet200Response
         */
        'last_modify'?: string | null;
        /**
         * 
         * @type {string}
         * @memberof V2GtfsTripsIdGet200Response
         */
        'route_id': string;
        /**
         * 
         * @type {string}
         * @memberof V2GtfsTripsIdGet200Response
         */
        'service_id': string;
        /**
         * 
         * @type {string}
         * @memberof V2GtfsTripsIdGet200Response
         */
        'shape_id': string;
        /**
         * 
         * @type {string}
         * @memberof V2GtfsTripsIdGet200Response
         */
        'trip_headsign': string;
        /**
         * 
         * @type {number}
         * @memberof V2GtfsTripsIdGet200Response
         */
        'wheelchair_accessible': number;
        /**
         * 
         * @type {Array<GTFSStopTime>}
         * @memberof V2GtfsTripsIdGet200Response
         */
        'stop_times'?: Array<GTFSStopTime>;
        /**
         * 
         * @type {Array<V2GtfsTripsIdGet200ResponseAllOfShapesInner>}
         * @memberof V2GtfsTripsIdGet200Response
         */
        'shapes'?: Array<V2GtfsTripsIdGet200ResponseAllOfShapesInner>;
        /**
         * 
         * @type {GTFSService}
         * @memberof V2GtfsTripsIdGet200Response
         */
        'service'?: GTFSService;
        /**
         * 
         * @type {GTFSRoute}
         * @memberof V2GtfsTripsIdGet200Response
         */
        'route'?: GTFSRoute;
    }
    
        /**
     * 
     * @export
     * @interface V2GtfsTripsIdGet200ResponseAllOfShapesInner
     */
    export interface V2GtfsTripsIdGet200ResponseAllOfShapesInner {
        /**
         * 
         * @type {FeaturePointGeometry}
         * @memberof V2GtfsTripsIdGet200ResponseAllOfShapesInner
         */
        'geometry': FeaturePointGeometry;
        /**
         * 
         * @type {GTFSShape}
         * @memberof V2GtfsTripsIdGet200ResponseAllOfShapesInner
         */
        'properties': GTFSShape;
        /**
         * 
         * @type {string}
         * @memberof V2GtfsTripsIdGet200ResponseAllOfShapesInner
         */
        'type': string;
    }
    
        /**
     * 
     * @export
     * @interface V2PidInfotextsGet200ResponseInner
     */
    export interface V2PidInfotextsGet200ResponseInner {
        /**
         * Intended time of infotext publishing in ISO String.
         * @type {string}
         * @memberof V2PidInfotextsGet200ResponseInner
         */
        'valid_from': string | null;
        /**
         * Intended time of infotext removal in ISO String. If `null`, the infotext is valid indefinitely
         * @type {string}
         * @memberof V2PidInfotextsGet200ResponseInner
         */
        'valid_to': string | null;
        /**
         * Information text in Czech.
         * @type {string}
         * @memberof V2PidInfotextsGet200ResponseInner
         */
        'text': string;
        /**
         * Information text in English.
         * @type {string}
         * @memberof V2PidInfotextsGet200ResponseInner
         */
        'text_en': string | null;
        /**
         * Type of display on board by the intended form of presentation (where applicable). Enumerating `inline` (to be presented along with departures, usually in a marquee), `general` (to be displayed full screen instead of departures).
         * @type {string}
         * @memberof V2PidInfotextsGet200ResponseInner
         */
        'display_type': V2PidInfotextsGet200ResponseInnerDisplayTypeEnum;
        /**
         * 
         * @type {Array<V2PidInfotextsGet200ResponseInnerAllOfRelatedStopsInner>}
         * @memberof V2PidInfotextsGet200ResponseInner
         */
        'related_stops'?: Array<V2PidInfotextsGet200ResponseInnerAllOfRelatedStopsInner>;
        /**
         * 
         * @type {Array<string>}
         * @memberof V2PidInfotextsGet200ResponseInner
         */
        'related_routes'?: Array<string>;
        /**
         * Legacy VYMI event identifier.
         * @type {number}
         * @memberof V2PidInfotextsGet200ResponseInner
         */
        'vymi_id'?: number;
        /**
         * Legacy VYMI database identifier.
         * @type {number}
         * @memberof V2PidInfotextsGet200ResponseInner
         */
        'vymi_id_dtb'?: number;
        /**
         * 
         * @type {string}
         * @memberof V2PidInfotextsGet200ResponseInner
         */
        'expiration_date'?: string | null;
        /**
         * 
         * @type {string}
         * @memberof V2PidInfotextsGet200ResponseInner
         */
        'last_updated'?: string;
        /**
         * Legacy ROPID VYMI user.
         * @type {string}
         * @memberof V2PidInfotextsGet200ResponseInner
         */
        'last_updated_user'?: string;
    }
    
    export const V2PidInfotextsGet200ResponseInnerDisplayTypeEnum = {
        Inline: 'inline',
        General: 'general'
    } as const;
    
    export type V2PidInfotextsGet200ResponseInnerDisplayTypeEnum = typeof V2PidInfotextsGet200ResponseInnerDisplayTypeEnum[keyof typeof V2PidInfotextsGet200ResponseInnerDisplayTypeEnum];
    
    
        /**
     * 
     * @export
     * @interface V2PidInfotextsGet200ResponseInnerAllOfRelatedStopsInner
     */
    export interface V2PidInfotextsGet200ResponseInnerAllOfRelatedStopsInner {
        /**
         * GTFS station IDs for which the infotexts apply.
         * @type {string}
         * @memberof V2PidInfotextsGet200ResponseInnerAllOfRelatedStopsInner
         */
        'id'?: string;
        /**
         * GTFS station name.
         * @type {string}
         * @memberof V2PidInfotextsGet200ResponseInnerAllOfRelatedStopsInner
         */
        'name'?: string;
        /**
         * GTFS station platform code.
         * @type {string}
         * @memberof V2PidInfotextsGet200ResponseInnerAllOfRelatedStopsInner
         */
        'platform_code'?: string | null;
    }
    
        /**
     * 
     * @export
     * @interface V2PublicGtfsTripsGtfsTripIdGet200Response
     */
    export interface V2PublicGtfsTripsGtfsTripIdGet200Response {
        /**
         * 
         * @type {string}
         * @memberof V2PublicGtfsTripsGtfsTripIdGet200Response
         */
        'gtfs_trip_id'?: string;
        /**
         * 
         * @type {string}
         * @memberof V2PublicGtfsTripsGtfsTripIdGet200Response
         */
        'route_type'?: V2PublicGtfsTripsGtfsTripIdGet200ResponseRouteTypeEnum;
        /**
         * 
         * @type {string}
         * @memberof V2PublicGtfsTripsGtfsTripIdGet200Response
         */
        'route_short_name'?: string;
        /**
         * 
         * @type {string}
         * @memberof V2PublicGtfsTripsGtfsTripIdGet200Response
         */
        'shape_id'?: string | null;
        /**
         * 
         * @type {string}
         * @memberof V2PublicGtfsTripsGtfsTripIdGet200Response
         */
        'origin_route_name'?: string | null;
        /**
         * 
         * @type {number}
         * @memberof V2PublicGtfsTripsGtfsTripIdGet200Response
         */
        'run_number'?: number | null;
        /**
         * 
         * @type {string}
         * @memberof V2PublicGtfsTripsGtfsTripIdGet200Response
         */
        'trip_headsign'?: string | null;
        /**
         * 
         * @type {PublicTripStaticStopTimeFeatureCollection}
         * @memberof V2PublicGtfsTripsGtfsTripIdGet200Response
         */
        'stop_times'?: PublicTripStaticStopTimeFeatureCollection;
        /**
         * 
         * @type {PublicTripShapeFeatureCollection}
         * @memberof V2PublicGtfsTripsGtfsTripIdGet200Response
         */
        'shapes'?: PublicTripShapeFeatureCollection;
        /**
         * 
         * @type {ScopeStaticVehicleDescriptorVehicleDescriptor}
         * @memberof V2PublicGtfsTripsGtfsTripIdGet200Response
         */
        'vehicle_descriptor'?: ScopeStaticVehicleDescriptorVehicleDescriptor;
    }
    
    export const V2PublicGtfsTripsGtfsTripIdGet200ResponseRouteTypeEnum = {
        Tram: 'tram',
        Metro: 'metro',
        Train: 'train',
        Bus: 'bus',
        Ferry: 'ferry',
        Funicular: 'funicular',
        Trolleybus: 'trolleybus',
        ExtMiscellaneous: 'ext_miscellaneous'
    } as const;
    
    export type V2PublicGtfsTripsGtfsTripIdGet200ResponseRouteTypeEnum = typeof V2PublicGtfsTripsGtfsTripIdGet200ResponseRouteTypeEnum[keyof typeof V2PublicGtfsTripsGtfsTripIdGet200ResponseRouteTypeEnum];
    
    
        /**
     * 
     * @export
     * @interface V2PublicVehiclepositionsGet200Response
     */
    export interface V2PublicVehiclepositionsGet200Response {
        /**
         * 
         * @type {Array<VehiclePositionsFeature>}
         * @memberof V2PublicVehiclepositionsGet200Response
         */
        'features'?: Array<VehiclePositionsFeature>;
        /**
         * 
         * @type {string}
         * @memberof V2PublicVehiclepositionsGet200Response
         */
        'type'?: string;
    }
    
        /**
     * 
     * @export
     * @interface V2PublicVehiclepositionsVehicleIdGet200Response
     */
    export interface V2PublicVehiclepositionsVehicleIdGet200Response {
        /**
         * 
         * @type {string}
         * @memberof V2PublicVehiclepositionsVehicleIdGet200Response
         */
        'gtfs_trip_id'?: string;
        /**
         * 
         * @type {string}
         * @memberof V2PublicVehiclepositionsVehicleIdGet200Response
         */
        'route_type'?: V2PublicVehiclepositionsVehicleIdGet200ResponseRouteTypeEnum;
        /**
         * 
         * @type {string}
         * @memberof V2PublicVehiclepositionsVehicleIdGet200Response
         */
        'route_short_name'?: string;
        /**
         * 
         * @type {string}
         * @memberof V2PublicVehiclepositionsVehicleIdGet200Response
         */
        'shape_id'?: string | null;
        /**
         * 
         * @type {string}
         * @memberof V2PublicVehiclepositionsVehicleIdGet200Response
         */
        'origin_route_name'?: string | null;
        /**
         * 
         * @type {number}
         * @memberof V2PublicVehiclepositionsVehicleIdGet200Response
         */
        'run_number'?: number | null;
        /**
         * 
         * @type {string}
         * @memberof V2PublicVehiclepositionsVehicleIdGet200Response
         */
        'trip_headsign'?: string | null;
        /**
         * 
         * @type {GeometryPoint}
         * @memberof V2PublicVehiclepositionsVehicleIdGet200Response
         */
        'geometry'?: GeometryPoint;
        /**
         * Distance travelled from the first stop of the trip.
         * @type {number}
         * @memberof V2PublicVehiclepositionsVehicleIdGet200Response
         */
        'shape_dist_traveled'?: number | null;
        /**
         * Bearing of the vehicle in degrees (0-360).
         * @type {number}
         * @memberof V2PublicVehiclepositionsVehicleIdGet200Response
         */
        'bearing'?: number | null;
        /**
         * Delay of the vehicle in seconds.
         * @type {number}
         * @memberof V2PublicVehiclepositionsVehicleIdGet200Response
         */
        'delay'?: number | null;
        /**
         * 
         * @type {StatePosition}
         * @memberof V2PublicVehiclepositionsVehicleIdGet200Response
         */
        'state_position'?: StatePosition;
        /**
         * index of last stop passed by the vehicle
         * @type {number}
         * @memberof V2PublicVehiclepositionsVehicleIdGet200Response
         */
        'last_stop_sequence'?: number | null;
        /**
         * time when vehicle send last update
         * @type {string}
         * @memberof V2PublicVehiclepositionsVehicleIdGet200Response
         */
        'origin_timestamp'?: string | null;
        /**
         * 
         * @type {PublicTripStopTimeFeatureCollection}
         * @memberof V2PublicVehiclepositionsVehicleIdGet200Response
         */
        'stop_times'?: PublicTripStopTimeFeatureCollection;
        /**
         * 
         * @type {PublicTripShapeFeatureCollection}
         * @memberof V2PublicVehiclepositionsVehicleIdGet200Response
         */
        'shapes'?: PublicTripShapeFeatureCollection;
        /**
         * 
         * @type {ScopeVehicleDescriptorVehicleDescriptor}
         * @memberof V2PublicVehiclepositionsVehicleIdGet200Response
         */
        'vehicle_descriptor'?: ScopeVehicleDescriptorVehicleDescriptor;
    }
    
    export const V2PublicVehiclepositionsVehicleIdGet200ResponseRouteTypeEnum = {
        Tram: 'tram',
        Metro: 'metro',
        Train: 'train',
        Bus: 'bus',
        Ferry: 'ferry',
        Funicular: 'funicular',
        Trolleybus: 'trolleybus',
        ExtMiscellaneous: 'ext_miscellaneous'
    } as const;
    
    export type V2PublicVehiclepositionsVehicleIdGet200ResponseRouteTypeEnum = typeof V2PublicVehiclepositionsVehicleIdGet200ResponseRouteTypeEnum[keyof typeof V2PublicVehiclepositionsVehicleIdGet200ResponseRouteTypeEnum];
    
    
        /**
     * 
     * @export
     * @interface V2VehiclepositionsGet200Response
     */
    export interface V2VehiclepositionsGet200Response {
        /**
         * 
         * @type {string}
         * @memberof V2VehiclepositionsGet200Response
         */
        'type'?: string;
        /**
         * 
         * @type {Array<V2VehiclepositionsGet200ResponseFeaturesInner>}
         * @memberof V2VehiclepositionsGet200Response
         */
        'features'?: Array<V2VehiclepositionsGet200ResponseFeaturesInner>;
    }
    
        /**
     * 
     * @export
     * @interface V2VehiclepositionsGet200ResponseFeaturesInner
     */
    export interface V2VehiclepositionsGet200ResponseFeaturesInner {
        /**
         * 
         * @type {FeaturePointGeometry}
         * @memberof V2VehiclepositionsGet200ResponseFeaturesInner
         */
        'geometry': FeaturePointGeometry;
        /**
         * 
         * @type {VehiclepositionCompound}
         * @memberof V2VehiclepositionsGet200ResponseFeaturesInner
         */
        'properties': VehiclepositionCompound;
        /**
         * 
         * @type {string}
         * @memberof V2VehiclepositionsGet200ResponseFeaturesInner
         */
        'type': string;
    }
    
        /**
     * 
     * @export
     * @interface V3PidDeparturepresetsGet200ResponseInner
     */
    export interface V3PidDeparturepresetsGet200ResponseInner {
        /**
         * 
         * @type {string}
         * @memberof V3PidDeparturepresetsGet200ResponseInner
         */
        'note'?: string;
        /**
         * 
         * @type {string}
         * @memberof V3PidDeparturepresetsGet200ResponseInner
         */
        'route_name'?: string;
        /**
         * 
         * @type {boolean}
         * @memberof V3PidDeparturepresetsGet200ResponseInner
         */
        'is_testing'?: boolean;
        /**
         * 
         * @type {Array<string>}
         * @memberof V3PidDeparturepresetsGet200ResponseInner
         */
        'stops'?: Array<string>;
    }
    
        /**
     * 
     * @export
     * @interface V3PidInfotextsGet200ResponseInner
     */
    export interface V3PidInfotextsGet200ResponseInner {
        /**
         * Intended time of infotext publishing in ISO String.
         * @type {string}
         * @memberof V3PidInfotextsGet200ResponseInner
         */
        'valid_from': string | null;
        /**
         * Intended time of infotext removal in ISO String. If `null`, the infotext is valid indefinitely
         * @type {string}
         * @memberof V3PidInfotextsGet200ResponseInner
         */
        'valid_to': string | null;
        /**
         * Information text in Czech.
         * @type {string}
         * @memberof V3PidInfotextsGet200ResponseInner
         */
        'text': string;
        /**
         * Information text in English.
         * @type {string}
         * @memberof V3PidInfotextsGet200ResponseInner
         */
        'text_en': string | null;
        /**
         * Type of display on board by the intended form of presentation (where applicable). Enumerating `inline` (to be presented along with departures, usually in a marquee), `general` (to be displayed full screen instead of departures).
         * @type {string}
         * @memberof V3PidInfotextsGet200ResponseInner
         */
        'display_type': V3PidInfotextsGet200ResponseInnerDisplayTypeEnum;
        /**
         * Priority of the infotext. If multiple infotexts are active for the same stop, the ones with higher priority will be displayed. Mapped from the VYMI (JIS) system\'s severity level in the following way: - \"INFO\" -> \"low\" - \"WARNING\" -> \"normal\" - \"SEVERE\" -> \"high\" 
         * @type {string}
         * @memberof V3PidInfotextsGet200ResponseInner
         */
        'priority': V3PidInfotextsGet200ResponseInnerPriorityEnum;
        /**
         * 
         * @type {Array<V3PidInfotextsGet200ResponseInnerAllOfRelatedStopsInner>}
         * @memberof V3PidInfotextsGet200ResponseInner
         */
        'related_stops': Array<V3PidInfotextsGet200ResponseInnerAllOfRelatedStopsInner>;
        /**
         * VYMI (JIS) Infotexts identifier.
         * @type {string}
         * @memberof V3PidInfotextsGet200ResponseInner
         */
        'id': string;
    }
    
    export const V3PidInfotextsGet200ResponseInnerDisplayTypeEnum = {
        Inline: 'inline',
        General: 'general'
    } as const;
    
    export type V3PidInfotextsGet200ResponseInnerDisplayTypeEnum = typeof V3PidInfotextsGet200ResponseInnerDisplayTypeEnum[keyof typeof V3PidInfotextsGet200ResponseInnerDisplayTypeEnum];
    export const V3PidInfotextsGet200ResponseInnerPriorityEnum = {
        Low: 'low',
        Normal: 'normal',
        High: 'high'
    } as const;
    
    export type V3PidInfotextsGet200ResponseInnerPriorityEnum = typeof V3PidInfotextsGet200ResponseInnerPriorityEnum[keyof typeof V3PidInfotextsGet200ResponseInnerPriorityEnum];
    
    
        /**
     * 
     * @export
     * @interface V3PidInfotextsGet200ResponseInnerAllOfRelatedStopsInner
     */
    export interface V3PidInfotextsGet200ResponseInnerAllOfRelatedStopsInner {
        /**
         * GTFS station IDs for which the infotexts apply.
         * @type {string}
         * @memberof V3PidInfotextsGet200ResponseInnerAllOfRelatedStopsInner
         */
        'id': string;
        /**
         * GTFS station name.
         * @type {string}
         * @memberof V3PidInfotextsGet200ResponseInnerAllOfRelatedStopsInner
         */
        'name': string;
        /**
         * GTFS station platform code.
         * @type {string}
         * @memberof V3PidInfotextsGet200ResponseInnerAllOfRelatedStopsInner
         */
        'platform_code': string | null;
    }
    
        /**
     * 
     * @export
     * @interface V3PidTransferboardsGet200Response
     */
    export interface V3PidTransferboardsGet200Response {
        /**
         * 
         * @type {Array<V3PidTransferboardsGet200ResponseDeparturesInner>}
         * @memberof V3PidTransferboardsGet200Response
         */
        'departures': Array<V3PidTransferboardsGet200ResponseDeparturesInner>;
        /**
         * 
         * @type {Array<V3PidTransferboardsGet200ResponseInfotextsInner>}
         * @memberof V3PidTransferboardsGet200Response
         */
        'infotexts': Array<V3PidTransferboardsGet200ResponseInfotextsInner>;
    }
    
        /**
     * 
     * @export
     * @interface V3PidTransferboardsGet200ResponseDeparturesInner
     */
    export interface V3PidTransferboardsGet200ResponseDeparturesInner {
        /**
         * 
         * @type {V3PidTransferboardsGet200ResponseDeparturesInnerDepartureTimestamp}
         * @memberof V3PidTransferboardsGet200ResponseDeparturesInner
         */
        'departure_timestamp': V3PidTransferboardsGet200ResponseDeparturesInnerDepartureTimestamp;
        /**
         * 
         * @type {V3PidTransferboardsGet200ResponseDeparturesInnerRoute}
         * @memberof V3PidTransferboardsGet200ResponseDeparturesInner
         */
        'route': V3PidTransferboardsGet200ResponseDeparturesInnerRoute;
        /**
         * 
         * @type {V3PidTransferboardsGet200ResponseDeparturesInnerStop}
         * @memberof V3PidTransferboardsGet200ResponseDeparturesInner
         */
        'stop': V3PidTransferboardsGet200ResponseDeparturesInnerStop;
        /**
         * 
         * @type {V3PidTransferboardsGet200ResponseDeparturesInnerTrip}
         * @memberof V3PidTransferboardsGet200ResponseDeparturesInner
         */
        'trip': V3PidTransferboardsGet200ResponseDeparturesInnerTrip;
    }
    
        /**
     * 
     * @export
     * @interface V3PidTransferboardsGet200ResponseDeparturesInnerDepartureTimestamp
     */
    export interface V3PidTransferboardsGet200ResponseDeparturesInnerDepartureTimestamp {
        /**
         * 
         * @type {string}
         * @memberof V3PidTransferboardsGet200ResponseDeparturesInnerDepartureTimestamp
         */
        'minutes': string | null;
    }
    
        /**
     * 
     * @export
     * @interface V3PidTransferboardsGet200ResponseDeparturesInnerRoute
     */
    export interface V3PidTransferboardsGet200ResponseDeparturesInnerRoute {
        /**
         * 
         * @type {string}
         * @memberof V3PidTransferboardsGet200ResponseDeparturesInnerRoute
         */
        'short_name': string | null;
        /**
         * 
         * @type {number}
         * @memberof V3PidTransferboardsGet200ResponseDeparturesInnerRoute
         */
        'type': number | null;
    }
    
        /**
     * 
     * @export
     * @interface V3PidTransferboardsGet200ResponseDeparturesInnerStop
     */
    export interface V3PidTransferboardsGet200ResponseDeparturesInnerStop {
        /**
         * 
         * @type {string}
         * @memberof V3PidTransferboardsGet200ResponseDeparturesInnerStop
         */
        'platform_code': string | null;
    }
    
        /**
     * 
     * @export
     * @interface V3PidTransferboardsGet200ResponseDeparturesInnerTrip
     */
    export interface V3PidTransferboardsGet200ResponseDeparturesInnerTrip {
        /**
         * 
         * @type {string}
         * @memberof V3PidTransferboardsGet200ResponseDeparturesInnerTrip
         */
        'headsign': string;
        /**
         * 
         * @type {string}
         * @memberof V3PidTransferboardsGet200ResponseDeparturesInnerTrip
         */
        'id': string;
    }
    
        /**
     * 
     * @export
     * @interface V3PidTransferboardsGet200ResponseInfotextsInner
     */
    export interface V3PidTransferboardsGet200ResponseInfotextsInner {
        /**
         * 
         * @type {string}
         * @memberof V3PidTransferboardsGet200ResponseInfotextsInner
         */
        'text': string;
        /**
         * 
         * @type {string}
         * @memberof V3PidTransferboardsGet200ResponseInfotextsInner
         */
        'text_en': string | null;
        /**
         * 
         * @type {string}
         * @memberof V3PidTransferboardsGet200ResponseInfotextsInner
         */
        'display_type': V3PidTransferboardsGet200ResponseInfotextsInnerDisplayTypeEnum;
    }
    
    export const V3PidTransferboardsGet200ResponseInfotextsInnerDisplayTypeEnum = {
        Inline: 'inline',
        General: 'general'
    } as const;
    
    export type V3PidTransferboardsGet200ResponseInfotextsInnerDisplayTypeEnum = typeof V3PidTransferboardsGet200ResponseInfotextsInnerDisplayTypeEnum[keyof typeof V3PidTransferboardsGet200ResponseInfotextsInnerDisplayTypeEnum];
    
    
        /**
     * 
     * @export
     * @interface V3PidTransferboardsGet404Response
     */
    export interface V3PidTransferboardsGet404Response {
        /**
         * 
         * @type {Array<object>}
         * @memberof V3PidTransferboardsGet404Response
         */
        'departures': Array<object>;
        /**
         * 
         * @type {Array<object>}
         * @memberof V3PidTransferboardsGet404Response
         */
        'infotexts': Array<object>;
    }
    
        /**
     * 
     * @export
     * @interface V4PidTransferboardsGet200Response
     */
    export interface V4PidTransferboardsGet200Response {
        /**
         * 
         * @type {string}
         * @memberof V4PidTransferboardsGet200Response
         */
        'platform_code': string | null;
        /**
         * 
         * @type {string}
         * @memberof V4PidTransferboardsGet200Response
         */
        'stop_name': string | null;
        /**
         * 
         * @type {Array<string | null>}
         * @memberof V4PidTransferboardsGet200Response
         */
        'icons'?: Array<string | null>;
        /**
         * List of departures from the stop. The list is sorted by: - route type - subway and then other   - subway is sorted alphabetically, then by departure time, then by direction id - departure time 
         * @type {Array<V4PidTransferboardsGet200ResponseDeparturesInner>}
         * @memberof V4PidTransferboardsGet200Response
         */
        'departures': Array<V4PidTransferboardsGet200ResponseDeparturesInner>;
        /**
         * 
         * @type {Array<V4PidTransferboardsGet200ResponseInfotextsInner>}
         * @memberof V4PidTransferboardsGet200Response
         */
        'infotexts': Array<V4PidTransferboardsGet200ResponseInfotextsInner>;
    }
    
        /**
     * 
     * @export
     * @interface V4PidTransferboardsGet200ResponseDeparturesInner
     */
    export interface V4PidTransferboardsGet200ResponseDeparturesInner {
        /**
         * 
         * @type {V4PidTransferboardsGet200ResponseDeparturesInnerDepartureTimestamp}
         * @memberof V4PidTransferboardsGet200ResponseDeparturesInner
         */
        'departure_timestamp': V4PidTransferboardsGet200ResponseDeparturesInnerDepartureTimestamp;
        /**
         * 
         * @type {V4PidTransferboardsGet200ResponseDeparturesInnerRoute}
         * @memberof V4PidTransferboardsGet200ResponseDeparturesInner
         */
        'route': V4PidTransferboardsGet200ResponseDeparturesInnerRoute;
        /**
         * 
         * @type {V3PidTransferboardsGet200ResponseDeparturesInnerStop}
         * @memberof V4PidTransferboardsGet200ResponseDeparturesInner
         */
        'stop'?: V3PidTransferboardsGet200ResponseDeparturesInnerStop;
        /**
         * 
         * @type {V4PidTransferboardsGet200ResponseDeparturesInnerTrip}
         * @memberof V4PidTransferboardsGet200ResponseDeparturesInner
         */
        'trip': V4PidTransferboardsGet200ResponseDeparturesInnerTrip;
        /**
         * 
         * @type {Array<string | null>}
         * @memberof V4PidTransferboardsGet200ResponseDeparturesInner
         */
        'icons'?: Array<string | null>;
        /**
         * 
         * @type {V4PidTransferboardsGet200ResponseDeparturesInnerSubstitutionText}
         * @memberof V4PidTransferboardsGet200ResponseDeparturesInner
         */
        'substitution_text'?: V4PidTransferboardsGet200ResponseDeparturesInnerSubstitutionText;
    }
    
        /**
     * 
     * @export
     * @interface V4PidTransferboardsGet200ResponseDeparturesInnerDepartureTimestamp
     */
    export interface V4PidTransferboardsGet200ResponseDeparturesInnerDepartureTimestamp {
        /**
         * 
         * @type {Array<string | null>}
         * @memberof V4PidTransferboardsGet200ResponseDeparturesInnerDepartureTimestamp
         */
        'minutes': Array<string | null>;
    }
    
        /**
     * 
     * @export
     * @interface V4PidTransferboardsGet200ResponseDeparturesInnerRoute
     */
    export interface V4PidTransferboardsGet200ResponseDeparturesInnerRoute {
        /**
         * 
         * @type {string}
         * @memberof V4PidTransferboardsGet200ResponseDeparturesInnerRoute
         */
        'short_name': string | null;
        /**
         * 
         * @type {number}
         * @memberof V4PidTransferboardsGet200ResponseDeparturesInnerRoute
         */
        'type': number | null;
    }
    
        /**
     * 
     * @export
     * @interface V4PidTransferboardsGet200ResponseDeparturesInnerSubstitutionText
     */
    export interface V4PidTransferboardsGet200ResponseDeparturesInnerSubstitutionText {
        /**
         * 
         * @type {string}
         * @memberof V4PidTransferboardsGet200ResponseDeparturesInnerSubstitutionText
         */
        'cs': string;
        /**
         * 
         * @type {string}
         * @memberof V4PidTransferboardsGet200ResponseDeparturesInnerSubstitutionText
         */
        'en'?: string | null;
    }
    
        /**
     * 
     * @export
     * @interface V4PidTransferboardsGet200ResponseDeparturesInnerTrip
     */
    export interface V4PidTransferboardsGet200ResponseDeparturesInnerTrip {
        /**
         * If more then one trips are available, the first one is taken. Trips are grouped by direction_id.
         * @type {string}
         * @memberof V4PidTransferboardsGet200ResponseDeparturesInnerTrip
         */
        'headsign': string;
        /**
         * If more then one trips are available, the first one is taken. Trips are grouped by direction_id.
         * @type {string}
         * @memberof V4PidTransferboardsGet200ResponseDeparturesInnerTrip
         */
        'id': string;
        /**
         * True if the vehicle being used on this trip is wheelchair accessible. Metro trips are deemed accessible if the station is accessible.
         * @type {boolean}
         * @memberof V4PidTransferboardsGet200ResponseDeparturesInnerTrip
         */
        'is_wheelchair_accessible': boolean;
    }
    
        /**
     * 
     * @export
     * @interface V4PidTransferboardsGet200ResponseInfotextsInner
     */
    export interface V4PidTransferboardsGet200ResponseInfotextsInner {
        /**
         * 
         * @type {V4PidTransferboardsGet200ResponseInfotextsInnerText}
         * @memberof V4PidTransferboardsGet200ResponseInfotextsInner
         */
        'text': V4PidTransferboardsGet200ResponseInfotextsInnerText | null;
        /**
         * 
         * @type {string}
         * @memberof V4PidTransferboardsGet200ResponseInfotextsInner
         */
        'display_type': V4PidTransferboardsGet200ResponseInfotextsInnerDisplayTypeEnum;
    }
    
    export const V4PidTransferboardsGet200ResponseInfotextsInnerDisplayTypeEnum = {
        Inline: 'inline',
        General: 'general'
    } as const;
    
    export type V4PidTransferboardsGet200ResponseInfotextsInnerDisplayTypeEnum = typeof V4PidTransferboardsGet200ResponseInfotextsInnerDisplayTypeEnum[keyof typeof V4PidTransferboardsGet200ResponseInfotextsInnerDisplayTypeEnum];
    
    
        /**
     * 
     * @export
     * @interface V4PidTransferboardsGet200ResponseInfotextsInnerText
     */
    export interface V4PidTransferboardsGet200ResponseInfotextsInnerText {
        /**
         * 
         * @type {string}
         * @memberof V4PidTransferboardsGet200ResponseInfotextsInnerText
         */
        'cs': string;
        /**
         * 
         * @type {string}
         * @memberof V4PidTransferboardsGet200ResponseInfotextsInnerText
         */
        'en'?: string;
    }
    
        /**
     * 
     * @export
     * @interface V4PidTransferboardsGet400Response
     */
    export interface V4PidTransferboardsGet400Response {
        /**
         * 
         * @type {string}
         * @memberof V4PidTransferboardsGet400Response
         */
        'error_message': string;
        /**
         * 
         * @type {number}
         * @memberof V4PidTransferboardsGet400Response
         */
        'error_status': number;
        /**
         * 
         * @type {string}
         * @memberof V4PidTransferboardsGet400Response
         */
        'error_info'?: string | null;
    }
    
        /**
     * 
     * @export
     * @interface VehiclePositionsFeature
     */
    export interface VehiclePositionsFeature {
        /**
         * 
         * @type {VehiclePositionsFeatureGeometry}
         * @memberof VehiclePositionsFeature
         */
        'geometry'?: VehiclePositionsFeatureGeometry;
        /**
         * 
         * @type {VehiclePositionsFeatureProperties}
         * @memberof VehiclePositionsFeature
         */
        'properties'?: VehiclePositionsFeatureProperties;
        /**
         * 
         * @type {string}
         * @memberof VehiclePositionsFeature
         */
        'type'?: string;
    }
    
        /**
     * GeoJson geometry
     * @export
     * @interface VehiclePositionsFeatureGeometry
     */
    export interface VehiclePositionsFeatureGeometry {
        /**
         * 
         * @type {VehiclePositionsFeatureGeometryCoordinates}
         * @memberof VehiclePositionsFeatureGeometry
         */
        'coordinates'?: VehiclePositionsFeatureGeometryCoordinates;
        /**
         * 
         * @type {string}
         * @memberof VehiclePositionsFeatureGeometry
         */
        'type'?: VehiclePositionsFeatureGeometryTypeEnum;
    }
    
    export const VehiclePositionsFeatureGeometryTypeEnum = {
        Point: 'Point',
        Polygon: 'Polygon',
        MultiPolygon: 'MultiPolygon'
    } as const;
    
    export type VehiclePositionsFeatureGeometryTypeEnum = typeof VehiclePositionsFeatureGeometryTypeEnum[keyof typeof VehiclePositionsFeatureGeometryTypeEnum];
    
    
        /**
     * @type VehiclePositionsFeatureGeometryCoordinates
     * @export
     */
    export type VehiclePositionsFeatureGeometryCoordinates = Array<Array<Array<Array<number>>>> | Array<Array<Array<number>>> | Array<number>;
    
        /**
     * 
     * @export
     * @interface VehiclePositionsFeatureProperties
     */
    export interface VehiclePositionsFeatureProperties {
        /**
         * 
         * @type {string}
         * @memberof VehiclePositionsFeatureProperties
         */
        'gtfs_trip_id': string;
        /**
         * 
         * @type {string}
         * @memberof VehiclePositionsFeatureProperties
         */
        'route_type': string;
        /**
         * 
         * @type {string}
         * @memberof VehiclePositionsFeatureProperties
         */
        'gtfs_route_short_name': string;
        /**
         * 
         * @type {number}
         * @memberof VehiclePositionsFeatureProperties
         */
        'bearing'?: number | null;
        /**
         * 
         * @type {number}
         * @memberof VehiclePositionsFeatureProperties
         */
        'delay'?: number | null;
        /**
         * 
         * @type {string}
         * @memberof VehiclePositionsFeatureProperties
         */
        'vehicle_id'?: string;
        /**
         * 
         * @type {StatePosition}
         * @memberof VehiclePositionsFeatureProperties
         */
        'state_position'?: StatePosition;
    }
    
    
    
        /**
     * 
     * @export
     * @interface VehiclepositionCompound
     */
    export interface VehiclepositionCompound {
        /**
         * 
         * @type {VehiclepositionTrip}
         * @memberof VehiclepositionCompound
         */
        'trip'?: VehiclepositionTrip;
        /**
         * 
         * @type {VehiclepositionPosition}
         * @memberof VehiclepositionCompound
         */
        'last_position'?: VehiclepositionPosition;
        /**
         * 
         * @type {VehiclepositionCompoundAllPositions}
         * @memberof VehiclepositionCompound
         */
        'all_positions'?: VehiclepositionCompoundAllPositions;
    }
    
        /**
     * All known positions with their properties
     * @export
     * @interface VehiclepositionCompoundAllPositions
     */
    export interface VehiclepositionCompoundAllPositions {
        /**
         * 
         * @type {string}
         * @memberof VehiclepositionCompoundAllPositions
         */
        'type': string;
        /**
         * 
         * @type {Array<VehiclepositionCompoundAllPositionsFeaturesInner>}
         * @memberof VehiclepositionCompoundAllPositions
         */
        'features'?: Array<VehiclepositionCompoundAllPositionsFeaturesInner>;
    }
    
        /**
     * 
     * @export
     * @interface VehiclepositionCompoundAllPositionsFeaturesInner
     */
    export interface VehiclepositionCompoundAllPositionsFeaturesInner {
        /**
         * 
         * @type {FeaturePointGeometry}
         * @memberof VehiclepositionCompoundAllPositionsFeaturesInner
         */
        'geometry': FeaturePointGeometry;
        /**
         * 
         * @type {VehiclepositionPosition}
         * @memberof VehiclepositionCompoundAllPositionsFeaturesInner
         */
        'properties': VehiclepositionPosition;
        /**
         * 
         * @type {string}
         * @memberof VehiclepositionCompoundAllPositionsFeaturesInner
         */
        'type': string;
    }
    
        /**
     * 
     * @export
     * @interface VehiclepositionPosition
     */
    export interface VehiclepositionPosition {
        /**
         * Bearing, in degrees (0 = north, 90 = east, 180 = south, 270 = west)
         * @type {number}
         * @memberof VehiclepositionPosition
         */
        'bearing': number | null;
        /**
         * 
         * @type {VehiclepositionPositionDelay}
         * @memberof VehiclepositionPosition
         */
        'delay'?: VehiclepositionPositionDelay;
        /**
         * 
         * @type {VehiclepositionPositionLastStop}
         * @memberof VehiclepositionPosition
         */
        'last_stop'?: VehiclepositionPositionLastStop;
        /**
         * 
         * @type {VehiclepositionPositionNextStop}
         * @memberof VehiclepositionPosition
         */
        'next_stop'?: VehiclepositionPositionNextStop;
        /**
         * True, if the trip was canceled. Other fields about the position have non-defined values in case this value is true
         * @type {boolean}
         * @memberof VehiclepositionPosition
         */
        'is_canceled': boolean | null;
        /**
         * Time at which the position was sent from the vehicle (UTC)
         * @type {string}
         * @memberof VehiclepositionPosition
         */
        'origin_timestamp': string;
        /**
         * Current speed of the vehicle (kilometers per hour)
         * @type {number}
         * @memberof VehiclepositionPosition
         */
        'speed'?: number | null;
        /**
         * Number of kilometers traveled on the route
         * @type {string}
         * @memberof VehiclepositionPosition
         */
        'shape_dist_traveled'?: string | null;
        /**
         * True if trip is tracked, meaning that trip is on its track.
         * @type {boolean}
         * @memberof VehiclepositionPosition
         */
        'tracking'?: boolean;
    }
    
        /**
     * 
     * @export
     * @interface VehiclepositionPositionDelay
     */
    export interface VehiclepositionPositionDelay {
        /**
         * Current delay, in seconds, based on actual location of a trip on its shape between stops
         * @type {number}
         * @memberof VehiclepositionPositionDelay
         */
        'actual'?: number | null;
        /**
         * Delay, in seconds, at the last confirmed stop on arrival. Null, if the arrival time to the last stop equal departure time
         * @type {number}
         * @memberof VehiclepositionPositionDelay
         */
        'last_stop_arrival'?: number | null;
        /**
         * Delay, in seconds, at the last confirmed stop on departure. Null, if it was a terminal stop.
         * @type {number}
         * @memberof VehiclepositionPositionDelay
         */
        'last_stop_departure'?: number | null;
    }
    
        /**
     * Properties for last stop passed
     * @export
     * @interface VehiclepositionPositionLastStop
     */
    export interface VehiclepositionPositionLastStop {
        /**
         * GTFS Static identifier of the last stop passed on the route of the trip
         * @type {string}
         * @memberof VehiclepositionPositionLastStop
         */
        'id': string | null;
        /**
         * Sequence number of the last stop passed on the route of the trip
         * @type {number}
         * @memberof VehiclepositionPositionLastStop
         */
        'sequence': number | null;
        /**
         * Scheduled arrival time to the last passed stop (UTC)
         * @type {string}
         * @memberof VehiclepositionPositionLastStop
         */
        'arrival_time': string | null;
        /**
         * Scheduled departure time from the last passed stop (UTC)
         * @type {string}
         * @memberof VehiclepositionPositionLastStop
         */
        'departure_time': string | null;
    }
    
        /**
     * Properties of the next stop on the route of the trip
     * @export
     * @interface VehiclepositionPositionNextStop
     */
    export interface VehiclepositionPositionNextStop {
        /**
         * GTFS Static identifier of the next stop on the route of the trip
         * @type {string}
         * @memberof VehiclepositionPositionNextStop
         */
        'id': string | null;
        /**
         * Sequence number of the next stop on the route of the trip
         * @type {number}
         * @memberof VehiclepositionPositionNextStop
         */
        'sequence': number | null;
        /**
         * Scheduled arrival time of the next stop on the route of the trip
         * @type {string}
         * @memberof VehiclepositionPositionNextStop
         */
        'arrival_time': string | null;
        /**
         * Scheduled departure time of the next stop on the route of the trip
         * @type {string}
         * @memberof VehiclepositionPositionNextStop
         */
        'departure_time': string | null;
    }
    
        /**
     * 
     * @export
     * @interface VehiclepositionTrip
     */
    export interface VehiclepositionTrip {
        /**
         * 
         * @type {VehiclepositionTripAgencyName}
         * @memberof VehiclepositionTrip
         */
        'agency_name'?: VehiclepositionTripAgencyName;
        /**
         * 
         * @type {VehiclepositionTripCis}
         * @memberof VehiclepositionTrip
         */
        'cis'?: VehiclepositionTripCis;
        /**
         * Identifier of trip sequence operated by a single vehicle
         * @type {number}
         * @memberof VehiclepositionTrip
         */
        'sequence_id': number;
        /**
         * Name of the route from which the vehicle originates
         * @type {string}
         * @memberof VehiclepositionTrip
         */
        'origin_route_name': string;
        /**
         * 
         * @type {VehiclepositionTripGtfs}
         * @memberof VehiclepositionTrip
         */
        'gtfs'?: VehiclepositionTripGtfs;
        /**
         * Timestamp of arrival time in first stop (UTC)
         * @type {string}
         * @memberof VehiclepositionTrip
         */
        'start_timestamp': string;
        /**
         * 
         * @type {VehiclepositionVehicleType}
         * @memberof VehiclepositionTrip
         */
        'vehicle_type'?: VehiclepositionVehicleType;
        /**
         * Four-digit identifier of the vehicle in the system
         * @type {number}
         * @memberof VehiclepositionTrip
         */
        'vehicle_registration_number': number;
        /**
         * Determines whether the vehicle has wheelchair access
         * @type {boolean}
         * @memberof VehiclepositionTrip
         */
        'wheelchair_accessible': boolean;
        /**
         * Determines whether the vehicle has air conditioning. If `null`, the information is not available or the vehicle\'s registration number is not known.
         * @type {boolean}
         * @memberof VehiclepositionTrip
         */
        'air_conditioned': boolean | null;
        /**
         * Determines whether the vehicle has USB chargers. If `null`, the information is not available or the vehicle\'s registration number is not known.
         * @type {boolean}
         * @memberof VehiclepositionTrip
         */
        'usb_chargers'?: boolean | null;
    }
    
        /**
     * 
     * @export
     * @interface VehiclepositionTripAgencyName
     */
    export interface VehiclepositionTripAgencyName {
        /**
         * Agency name that normally operates the trip
         * @type {string}
         * @memberof VehiclepositionTripAgencyName
         */
        'real': string;
        /**
         * Agency name that currently operates the trip (normally identical to planned_agency_name)
         * @type {string}
         * @memberof VehiclepositionTripAgencyName
         */
        'scheduled': string;
    }
    
        /**
     * All properties that come from nation central information system
     * @export
     * @interface VehiclepositionTripCis
     */
    export interface VehiclepositionTripCis {
        /**
         * Full line number
         * @type {string}
         * @memberof VehiclepositionTripCis
         */
        'line_id': string;
        /**
         * Trip number (unique within specific cis_line_id)
         * @type {number}
         * @memberof VehiclepositionTripCis
         */
        'trip_number': number;
    }
    
        /**
     * All properties tied with GTFS data format
     * @export
     * @interface VehiclepositionTripGtfs
     */
    export interface VehiclepositionTripGtfs {
        /**
         * Identifier of the owner route in the GTFS Static feed
         * @type {string}
         * @memberof VehiclepositionTripGtfs
         */
        'route_id': string;
        /**
         * Identification of the line used for the public
         * @type {string}
         * @memberof VehiclepositionTripGtfs
         */
        'route_short_name': string;
        /**
         * Identifier of the route type in the GTFS Static feed
         * @type {number}
         * @memberof VehiclepositionTripGtfs
         */
        'route_type': number;
        /**
         * Identifier of the trip in the GTFS Static feed
         * @type {string}
         * @memberof VehiclepositionTripGtfs
         */
        'trip_id': string;
        /**
         * Heading of the trip (identical to what is shown on the bus)
         * @type {string}
         * @memberof VehiclepositionTripGtfs
         */
        'trip_headsign'?: string | null;
    }
    
        /**
     * 
     * @export
     * @interface VehiclepositionVehicleType
     */
    export interface VehiclepositionVehicleType {
        /**
         * Unique id code of type
         * @type {number}
         * @memberof VehiclepositionVehicleType
         */
        'id': number;
        /**
         * Description of type in Czech
         * @type {string}
         * @memberof VehiclepositionVehicleType
         */
        'description_cs': string;
        /**
         * Description of type in English
         * @type {string}
         * @memberof VehiclepositionVehicleType
         */
        'description_en': string;
    }
    
        
        
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    /**
     * GTFSRealtimeV2Api - object-oriented interface
     * @export
     * @class GTFSRealtimeV2Api
     * @extends {BaseAPI}
     */
    export class GTFSRealtimeV2Api extends BaseAPI {
    
        constructor(protected override configuration: GolemioPublicTransportApiConfiguration, protected override axios: AxiosInstance = globalAxios) {
            super(configuration, configuration.basePath, axios);
        }
    
        /**
         * 
         * @summary GET GTFS-RT Service Alerts Feed
    
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof GTFSRealtimeV2Api
         */
        
        public async v2VehiclepositionsGtfsrtAlertsPbGet(
            options: AxiosRequestConfig = {}
        ) {
    
            const localVarPath = `/v2/vehiclepositions/gtfsrt/alerts.pb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<File>(axiosRequestConfig);
        }
    
        /**
         * 
         * @summary GET GTFS-RT PID Feed (trip updates and vehicle positions, combined)
    
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof GTFSRealtimeV2Api
         */
        
        public async v2VehiclepositionsGtfsrtPidFeedPbGet(
            options: AxiosRequestConfig = {}
        ) {
    
            const localVarPath = `/v2/vehiclepositions/gtfsrt/pid_feed.pb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<File>(axiosRequestConfig);
        }
    
        /**
         * 
         * @summary GET GTFS-RT Trip Updates Feed
    
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof GTFSRealtimeV2Api
         */
        
        public async v2VehiclepositionsGtfsrtTripUpdatesPbGet(
            options: AxiosRequestConfig = {}
        ) {
    
            const localVarPath = `/v2/vehiclepositions/gtfsrt/trip_updates.pb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<File>(axiosRequestConfig);
        }
    
        /**
         * 
         * @summary GET GTFS-RT Vehicle Positions Feed
    
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof GTFSRealtimeV2Api
         */
        
        public async v2VehiclepositionsGtfsrtVehiclePositionsPbGet(
            options: AxiosRequestConfig = {}
        ) {
    
            const localVarPath = `/v2/vehiclepositions/gtfsrt/vehicle_positions.pb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<File>(axiosRequestConfig);
        }
    }
    
        
        
    
    
    /**
     * Query parameters for v2GtfsRoutesGet operation in GTFSStaticV2Api.
     * @export
     * @interface GTFSStaticV2ApiV2GtfsRoutesGetQueryParams
     */
    export interface GTFSStaticV2ApiV2GtfsRoutesGetQueryParams {
        //limit
        /**
         * Limits number of retrieved items. The maximum is 10000 (default value).
         * @type {number}
         * @memberof GTFSStaticV2ApiV2GtfsRoutesGet
         */
        limit?: number
    
        //offset
        /**
         * Number of the first items that are skipped.
         * @type {number}
         * @memberof GTFSStaticV2ApiV2GtfsRoutesGet
         */
        offset?: number
    }
    
    
    
    
    
    
    
    
    
    /**
     * Query parameters for v2GtfsServicesGet operation in GTFSStaticV2Api.
     * @export
     * @interface GTFSStaticV2ApiV2GtfsServicesGetQueryParams
     */
    export interface GTFSStaticV2ApiV2GtfsServicesGetQueryParams {
        //date
        /**
         * Filter services by specific date in format (YYYY-MM-DD).
         * @type {string}
         * @memberof GTFSStaticV2ApiV2GtfsServicesGet
         */
        date?: string
    
        //limit
        /**
         * Limits number of retrieved items. The maximum is 10000 (default value).
         * @type {number}
         * @memberof GTFSStaticV2ApiV2GtfsServicesGet
         */
        limit?: number
    
        //offset
        /**
         * Number of the first items that are skipped.
         * @type {number}
         * @memberof GTFSStaticV2ApiV2GtfsServicesGet
         */
        offset?: number
    }
    
    
    
    
    
    
    
    
    
    /**
     * Query parameters for v2GtfsStopsGet operation in GTFSStaticV2Api.
     * @export
     * @interface GTFSStaticV2ApiV2GtfsStopsGetQueryParams
     */
    export interface GTFSStaticV2ApiV2GtfsStopsGetQueryParams {
        //names
        /**
         * Name of station. Use with square brackets &#x60;names[]&#x3D;NAME1&amp;names[]&#x3D;NAME2&#x60;.
         * @type {string}
         * @memberof GTFSStaticV2ApiV2GtfsStopsGet
         */
        names?: string
    
        //ids
        /**
         * Get stops by stop_id. Use with square brackets &#x60;ids[]&#x60;.
         * @type {string}
         * @memberof GTFSStaticV2ApiV2GtfsStopsGet
         */
        ids?: string
    
        //aswIds
        /**
         * Get stops by ASW, use &#x60;_&#x60; instead of &#x60;/&#x60; or encode the slash sign with &#x60;%2F&#x60;. Use with square brackets &#x60;aswId[]&#x60;.
         * @type {string}
         * @memberof GTFSStaticV2ApiV2GtfsStopsGet
         */
        aswIds?: string
    
        //cisIds
        /**
         * Limits number of retrieved items. The maximum is 10000 (default value).
         * @type {number}
         * @memberof GTFSStaticV2ApiV2GtfsStopsGet
         */
        cisIds?: number
    
        //limit
        /**
         * Limits number of retrieved items. The maximum is 10000 (default value).
         * @type {number}
         * @memberof GTFSStaticV2ApiV2GtfsStopsGet
         */
        limit?: number
    
        //offset
        /**
         * Number of the first items that are skipped.
         * @type {number}
         * @memberof GTFSStaticV2ApiV2GtfsStopsGet
         */
        offset?: number
    }
    
    
    
    
    
    
    
    
    
    /**
     * Query parameters for v2GtfsStoptimesIdGet operation in GTFSStaticV2Api.
     * @export
     * @interface GTFSStaticV2ApiV2GtfsStoptimesIdGetQueryParams
     */
    export interface GTFSStaticV2ApiV2GtfsStoptimesIdGetQueryParams {
        //date
        /**
         * Filter stop times by specific date in format (YYYY-MM-DD).
         * @type {string}
         * @memberof GTFSStaticV2ApiV2GtfsStoptimesIdGet
         */
        date?: string
    
        //from
        /**
         * Filter stop times by time departure in format (H:mm:ss).
         * @type {string}
         * @memberof GTFSStaticV2ApiV2GtfsStoptimesIdGet
         */
        from?: string
    
        //to
        /**
         * Filter stop times by time arrival in format (H:mm:ss).
         * @type {string}
         * @memberof GTFSStaticV2ApiV2GtfsStoptimesIdGet
         */
        to?: string
    
        //includeStop
        /**
         * Enrich stop times response object with stop.
         * @type {boolean}
         * @memberof GTFSStaticV2ApiV2GtfsStoptimesIdGet
         */
        includeStop?: boolean
    
        //limit
        /**
         * Limits number of retrieved items. The maximum is 10000 (default value).
         * @type {number}
         * @memberof GTFSStaticV2ApiV2GtfsStoptimesIdGet
         */
        limit?: number
    
        //offset
        /**
         * Number of the first items that are skipped.
         * @type {number}
         * @memberof GTFSStaticV2ApiV2GtfsStoptimesIdGet
         */
        offset?: number
    }
    
    
    
    
    
    /**
     * Query parameters for v2GtfsTripsGet operation in GTFSStaticV2Api.
     * @export
     * @interface GTFSStaticV2ApiV2GtfsTripsGetQueryParams
     */
    export interface GTFSStaticV2ApiV2GtfsTripsGetQueryParams {
        //stopId
        /**
         * Filter trips that include specific stop.
         * @type {string}
         * @memberof GTFSStaticV2ApiV2GtfsTripsGet
         */
        stopId?: string
    
        //date
        /**
         * Filter trips by specific date.
         * @type {string}
         * @memberof GTFSStaticV2ApiV2GtfsTripsGet
         */
        date?: string
    
        //limit
        /**
         * Limits number of retrieved items. The maximum is 10000 (default value).
         * @type {number}
         * @memberof GTFSStaticV2ApiV2GtfsTripsGet
         */
        limit?: number
    
        //offset
        /**
         * Number of the first items that are skipped.
         * @type {number}
         * @memberof GTFSStaticV2ApiV2GtfsTripsGet
         */
        offset?: number
    }
    
    
    
    
    
    /**
     * Query parameters for v2GtfsTripsIdGet operation in GTFSStaticV2Api.
     * @export
     * @interface GTFSStaticV2ApiV2GtfsTripsIdGetQueryParams
     */
    export interface GTFSStaticV2ApiV2GtfsTripsIdGetQueryParams {
        //includeShapes
        /**
         * Enrich trip response object with shapes.
         * @type {boolean}
         * @memberof GTFSStaticV2ApiV2GtfsTripsIdGet
         */
        includeShapes?: boolean
    
        //includeStops
        /**
         * Enrich trip response object with stops.
         * @type {boolean}
         * @memberof GTFSStaticV2ApiV2GtfsTripsIdGet
         */
        includeStops?: boolean
    
        //includeStopTimes
        /**
         * Enrich trip response object with stops times.
         * @type {boolean}
         * @memberof GTFSStaticV2ApiV2GtfsTripsIdGet
         */
        includeStopTimes?: boolean
    
        //includeService
        /**
         * Enrich trip response object with service.
         * @type {boolean}
         * @memberof GTFSStaticV2ApiV2GtfsTripsIdGet
         */
        includeService?: boolean
    
        //includeRoute
        /**
         * Enrich trip response object with routes.
         * @type {boolean}
         * @memberof GTFSStaticV2ApiV2GtfsTripsIdGet
         */
        includeRoute?: boolean
    
        //date
        /**
         * Filter trips by specific date in format (YYYY-MM-DD).
         * @type {string}
         * @memberof GTFSStaticV2ApiV2GtfsTripsIdGet
         */
        date?: string
    }
    
    
    
    
    /**
     * GTFSStaticV2Api - object-oriented interface
     * @export
     * @class GTFSStaticV2Api
     * @extends {BaseAPI}
     */
    export class GTFSStaticV2Api extends BaseAPI {
    
        constructor(protected override configuration: GolemioPublicTransportApiConfiguration, protected override axios: AxiosInstance = globalAxios) {
            super(configuration, configuration.basePath, axios);
        }
    
        /**
         * 
         * @summary GET All GTFS Routes
    
         * @param {GTFSStaticV2ApiV2GtfsRoutesGetQueryParams} queryParams Query parameters.
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof GTFSStaticV2Api
         */
        
        public async v2GtfsRoutesGet(
            queryParams: GTFSStaticV2ApiV2GtfsRoutesGetQueryParams = {},
            options: AxiosRequestConfig = {}
        ) {
    
            const localVarPath = `/v2/gtfs/routes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
            if (queryParams.limit !== undefined) {
                requestQueryParameter['limit'] = queryParams.limit;
            }
    
            if (queryParams.offset !== undefined) {
                requestQueryParameter['offset'] = queryParams.offset;
            }
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<Array<GTFSRoute>>(axiosRequestConfig);
        }
    
        /**
         * 
         * @summary GET GTFS Route
    
         * @param {string} id 
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof GTFSStaticV2Api
         */
        
        public async v2GtfsRoutesIdGet(
            id: string,
            options: AxiosRequestConfig = {}
        ) {
    
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v2GtfsRoutesIdGet', 'id', id)
            
            const localVarPath = `/v2/gtfs/routes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<GTFSRoute>(axiosRequestConfig);
        }
    
        /**
         * 
         * @summary GET GTFS Services
    
         * @param {GTFSStaticV2ApiV2GtfsServicesGetQueryParams} queryParams Query parameters.
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof GTFSStaticV2Api
         */
        
        public async v2GtfsServicesGet(
            queryParams: GTFSStaticV2ApiV2GtfsServicesGetQueryParams = {},
            options: AxiosRequestConfig = {}
        ) {
    
            const localVarPath = `/v2/gtfs/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
            if (queryParams.date !== undefined) {
                requestQueryParameter['date'] = queryParams.date;
            }
    
            if (queryParams.limit !== undefined) {
                requestQueryParameter['limit'] = queryParams.limit;
            }
    
            if (queryParams.offset !== undefined) {
                requestQueryParameter['offset'] = queryParams.offset;
            }
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<Array<GTFSService>>(axiosRequestConfig);
        }
    
        /**
         * 
         * @summary GET GTFS Shape
    
         * @param {string} id 
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof GTFSStaticV2Api
         */
        
        public async v2GtfsShapesIdGet(
            id: string,
            options: AxiosRequestConfig = {}
        ) {
    
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v2GtfsShapesIdGet', 'id', id)
            
            const localVarPath = `/v2/gtfs/shapes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<V2GtfsShapesIdGet200Response>(axiosRequestConfig);
        }
    
        /**
         * 
         * @summary GET All GTFS Stops
    
         * @param {GTFSStaticV2ApiV2GtfsStopsGetQueryParams} queryParams Query parameters.
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof GTFSStaticV2Api
         */
        
        public async v2GtfsStopsGet(
            queryParams: GTFSStaticV2ApiV2GtfsStopsGetQueryParams = {},
            options: AxiosRequestConfig = {}
        ) {
    
            const localVarPath = `/v2/gtfs/stops`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
            if (queryParams.names !== undefined) {
                requestQueryParameter['names'] = queryParams.names;
            }
    
            if (queryParams.ids !== undefined) {
                requestQueryParameter['ids'] = queryParams.ids;
            }
    
            if (queryParams.aswIds !== undefined) {
                requestQueryParameter['aswIds'] = queryParams.aswIds;
            }
    
            if (queryParams.cisIds !== undefined) {
                requestQueryParameter['cisIds'] = queryParams.cisIds;
            }
    
            if (queryParams.limit !== undefined) {
                requestQueryParameter['limit'] = queryParams.limit;
            }
    
            if (queryParams.offset !== undefined) {
                requestQueryParameter['offset'] = queryParams.offset;
            }
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<V2GtfsStopsGet200Response>(axiosRequestConfig);
        }
    
        /**
         * 
         * @summary GET GTFS Stop
    
         * @param {string} id 
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof GTFSStaticV2Api
         */
        
        public async v2GtfsStopsIdGet(
            id: string,
            options: AxiosRequestConfig = {}
        ) {
    
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v2GtfsStopsIdGet', 'id', id)
            
            const localVarPath = `/v2/gtfs/stops/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<V2GtfsStopsGet200ResponseFeaturesInner>(axiosRequestConfig);
        }
    
        /**
         * 
         * @summary GET GTFS Stop times
    
         * @param {string} id 
         * @param {GTFSStaticV2ApiV2GtfsStoptimesIdGetQueryParams} queryParams Query parameters.
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof GTFSStaticV2Api
         */
        
        public async v2GtfsStoptimesIdGet(
            id: string,
            queryParams: GTFSStaticV2ApiV2GtfsStoptimesIdGetQueryParams,
            options: AxiosRequestConfig = {}
        ) {
    
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v2GtfsStoptimesIdGet', 'id', id)
            
            const localVarPath = `/v2/gtfs/stoptimes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
            if (queryParams.date !== undefined) {
                requestQueryParameter['date'] = queryParams.date;
            }
    
            if (queryParams.from !== undefined) {
                requestQueryParameter['from'] = queryParams.from;
            }
    
            if (queryParams.to !== undefined) {
                requestQueryParameter['to'] = queryParams.to;
            }
    
            if (queryParams.includeStop !== undefined) {
                requestQueryParameter['includeStop'] = queryParams.includeStop;
            }
    
            if (queryParams.limit !== undefined) {
                requestQueryParameter['limit'] = queryParams.limit;
            }
    
            if (queryParams.offset !== undefined) {
                requestQueryParameter['offset'] = queryParams.offset;
            }
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<Array<GTFSStopTime>>(axiosRequestConfig);
        }
    
        /**
         * 
         * @summary GET All GTFS Trips
    
         * @param {GTFSStaticV2ApiV2GtfsTripsGetQueryParams} queryParams Query parameters.
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof GTFSStaticV2Api
         */
        
        public async v2GtfsTripsGet(
            queryParams: GTFSStaticV2ApiV2GtfsTripsGetQueryParams = {},
            options: AxiosRequestConfig = {}
        ) {
    
            const localVarPath = `/v2/gtfs/trips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
            if (queryParams.stopId !== undefined) {
                requestQueryParameter['stopId'] = queryParams.stopId;
            }
    
            if (queryParams.date !== undefined) {
                requestQueryParameter['date'] = queryParams.date;
            }
    
            if (queryParams.limit !== undefined) {
                requestQueryParameter['limit'] = queryParams.limit;
            }
    
            if (queryParams.offset !== undefined) {
                requestQueryParameter['offset'] = queryParams.offset;
            }
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<Array<GTFSTrip>>(axiosRequestConfig);
        }
    
        /**
         * 
         * @summary GET GTFS Trip
    
         * @param {string} id 
         * @param {GTFSStaticV2ApiV2GtfsTripsIdGetQueryParams} queryParams Query parameters.
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof GTFSStaticV2Api
         */
        
        public async v2GtfsTripsIdGet(
            id: string,
            queryParams: GTFSStaticV2ApiV2GtfsTripsIdGetQueryParams,
            options: AxiosRequestConfig = {}
        ) {
    
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v2GtfsTripsIdGet', 'id', id)
            
            const localVarPath = `/v2/gtfs/trips/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
            if (queryParams.includeShapes !== undefined) {
                requestQueryParameter['includeShapes'] = queryParams.includeShapes;
            }
    
            if (queryParams.includeStops !== undefined) {
                requestQueryParameter['includeStops'] = queryParams.includeStops;
            }
    
            if (queryParams.includeStopTimes !== undefined) {
                requestQueryParameter['includeStopTimes'] = queryParams.includeStopTimes;
            }
    
            if (queryParams.includeService !== undefined) {
                requestQueryParameter['includeService'] = queryParams.includeService;
            }
    
            if (queryParams.includeRoute !== undefined) {
                requestQueryParameter['includeRoute'] = queryParams.includeRoute;
            }
    
            if (queryParams.date !== undefined) {
                requestQueryParameter['date'] = queryParams.date;
            }
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<V2GtfsTripsIdGet200Response>(axiosRequestConfig);
        }
    }
    
        
        
    
    
    /**
     * Query parameters for v1JisEventsCustomFormatGet operation in JISV1InternalApi.
     * @export
     * @interface JISV1InternalApiV1JisEventsCustomFormatGetQueryParams
     */
    export interface JISV1InternalApiV1JisEventsCustomFormatGetQueryParams {
        //displayPeriodStart
        /**
         * Start of the display period
         * @type {string}
         * @memberof JISV1InternalApiV1JisEventsCustomFormatGet
         */
        displayPeriodStart?: string
    
        //displayPeriodEnd
        /**
         * End of the display period
         * @type {string}
         * @memberof JISV1InternalApiV1JisEventsCustomFormatGet
         */
        displayPeriodEnd?: string
    
        //organizationNames
        /**
         * List of organization names to filter events by.
         * @type {Array<string>}
         * @memberof JISV1InternalApiV1JisEventsCustomFormatGet
         */
        organizationNames?: Array<string>
    }
    
    
    
    
    /**
     * JISV1InternalApi - object-oriented interface
     * @export
     * @class JISV1InternalApi
     * @extends {BaseAPI}
     */
    export class JISV1InternalApi extends BaseAPI {
    
        constructor(protected override configuration: GolemioPublicTransportApiConfiguration, protected override axios: AxiosInstance = globalAxios) {
            super(configuration, configuration.basePath, axios);
        }
    
        /**
         * 
         * @summary Get all published events in custom format for external use
    
         * @param {JISV1InternalApiV1JisEventsCustomFormatGetQueryParams} queryParams Query parameters.
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof JISV1InternalApi
         */
        
        public async v1JisEventsCustomFormatGet(
            queryParams: JISV1InternalApiV1JisEventsCustomFormatGetQueryParams = {},
            options: AxiosRequestConfig = {}
        ) {
    
            const localVarPath = `/v1/jis/events/custom-format`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
            if (queryParams.displayPeriodStart !== undefined) {
                requestQueryParameter['displayPeriodStart'] = (queryParams.displayPeriodStart as any instanceof Date) ?
                    (queryParams.displayPeriodStart as any).toISOString() :
                    queryParams.displayPeriodStart;
            }
    
            if (queryParams.displayPeriodEnd !== undefined) {
                requestQueryParameter['displayPeriodEnd'] = (queryParams.displayPeriodEnd as any instanceof Date) ?
                    (queryParams.displayPeriodEnd as any).toISOString() :
                    queryParams.displayPeriodEnd;
            }
    
            if (queryParams.organizationNames) {
                requestQueryParameter['organizationNames'] = queryParams.organizationNames;
            }
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<Array<EventCustomFormat>>(axiosRequestConfig);
        }
    }
    
        
        
    /**
     * @export
     */
    export const V2PidDepartureboardsGetSkipEnum = {
        Canceled: 'canceled',
        AtStop: 'atStop',
        Untracked: 'untracked',
        Missing: 'missing'
    } as const;
    export type V2PidDepartureboardsGetSkipEnum = typeof V2PidDepartureboardsGetSkipEnum[keyof typeof V2PidDepartureboardsGetSkipEnum];
    
    
    /**
     * Query parameters for v2PidDepartureboardsGet operation in PIDDepartureBoardsV2Api.
     * @export
     * @interface PIDDepartureBoardsV2ApiV2PidDepartureboardsGetQueryParams
     */
    export interface PIDDepartureBoardsV2ApiV2PidDepartureboardsGetQueryParams {
        //ids
        /**
         * Get result by GTFS stop_id. Can be used to retrive individual stops and to separate departures of Prague and intercity routes, even if they depart from the same physical stop. A list of GTFS stops can be found in &#x60;stops.txt&#x60; file of the [GTFS feed](https://opendata.praha.eu/datasets/https%3A%2F%2Fapi.opendata.praha.eu%2Flod%2Fcatalog%2F9a6a1d8e-45b9-41de-b9ae-0bcec7126876).
         * @type {string}
         * @memberof PIDDepartureBoardsV2ApiV2PidDepartureboardsGet
         */
        ids?: string
    
        //aswIds
        /**
         * Get result by ASW ID. First part of the number represents the whole node. Usually it groups the stops of the same name or all stops associated with a metro station. Also returns related train stations in the node. The second part of the number is optional and represents individual stops in the node. Use &#x60;_&#x60; instead of &#x60;/&#x60; as a separator or encode the slash sign with &#x60;%2F&#x60;. A list of ASW IDs can be found in [Prague Open data](https://opendata.praha.eu/datasets/https%3A%2F%2Fapi.opendata.praha.eu%2Flod%2Fcatalog%2F6ac8381f-ea19-4ea9-8949-92076809dc5a). ‚ö†Ô∏è Note: combination with &#x60;includeMetroTrains&#x60; is currently not supported, see [issue pid#222](https://gitlab.com/operator-ict/golemio/code/modules/pid/-/issues/222).
         * @type {string}
         * @memberof PIDDepartureBoardsV2ApiV2PidDepartureboardsGet
         */
        aswIds?: string
    
        //cisIds
        /**
         * Get result by CIS ID. A list of CIS IDs can be found in [Prague Open data](https://opendata.praha.eu/datasets/https%3A%2F%2Fapi.opendata.praha.eu%2Flod%2Fcatalog%2F6ac8381f-ea19-4ea9-8949-92076809dc5a).
         * @type {number}
         * @memberof PIDDepartureBoardsV2ApiV2PidDepartureboardsGet
         */
        cisIds?: number
    
        //names
        /**
         * Get results by exact name of stop (case and whitespace sensitive). May return stops of the same name from different towns. Using &#x60;names&#x60; in combination with other identifiers will return an intersection of stops with &#x60;names&#x60; and stops of ASW, CIS or GTFS identifiers in the same node. Use this feature to filter out a subset of stops of the same name while guaranteeing them to be from the desired node only.
         * @type {string}
         * @memberof PIDDepartureBoardsV2ApiV2PidDepartureboardsGet
         */
        names?: string
    
        //minutesBefore
        /**
         * Set the start of interval from which to retrieve departures. Positive numbers are set in past relative to the time of request or &#x60;timeFrom&#x60; timestamp, negative numbers set the start in the future. Use to compensate for walking distance to a stop. Default is set to 0. Maximum value is 30 because of implemented data retention. Minimum value is -4320 (0 - 3 days GTFS calendar maximum).
         * @type {number}
         * @memberof PIDDepartureBoardsV2ApiV2PidDepartureboardsGet
         */
        minutesBefore?: number
    
        //minutesAfter
        /**
         * Set the end of interval from which to retrieve departures. Positive numbers are set in future relative to the time of request or &#x60;timeFrom&#x60; timestamp, negative are in the past. The sum of minutesBefore and minutesAfter must be larger than zero. Default is set to 180. Maximum value is 4320 (GTFS calendar maximum). Minimum value is -4350 (0 - 3 days GTFS calendar maximum - 30 minutes data retention).
         * @type {number}
         * @memberof PIDDepartureBoardsV2ApiV2PidDepartureboardsGet
         */
        minutesAfter?: number
    
        //timeFrom
        /**
         * Set initial timestamp for time interval given by &#x60;minutesBefore&#x60; and &#x60;minutesAfter&#x60;. Use to simulate query time different from now. Use ISO 8601 time format and URL encoded symbols - &#x60;%3A&#x60; for &#x60;:&#x60;, &#x60;%2B&#x60; for &#x60;.&#x60;, &#x60;%2F&#x60; for &#x60;+&#x60;. Time zone is set according to the &#x60;preferredTimezone&#x60; parameter. Applicable range is -6 hours +2 days from now.
         * @type {string}
         * @memberof PIDDepartureBoardsV2ApiV2PidDepartureboardsGet
         */
        timeFrom?: string
    
        //includeMetroTrains
        /**
         * When selecting a node by &#x60;name&#x60;, when &#x60;true&#x60;, will include metro and/or train stops that are a member of the same node. I.e. when querying _Na Kn√≠≈æec√≠_, setting this to &#x60;true&#x60; will add the metro station _Andƒõl_ to results as well because both have the same ASW node number 1040. ‚ö†Ô∏è Note: combination with &#x60;aswIds&#x60; is currently not supported, see [issue pid#222](https://gitlab.com/operator-ict/golemio/code/modules/pid/-/issues/222).
         * @type {boolean}
         * @memberof PIDDepartureBoardsV2ApiV2PidDepartureboardsGet
         */
        includeMetroTrains?: boolean
    
        //airCondition
        /**
         * Enrich departures with vehicle air condition information. Setting to &#x60;false&#x60; will force all items to be &#x60;null&#x60;. Useful for disabling the indication of air condition during cold season.
         * @type {boolean}
         * @memberof PIDDepartureBoardsV2ApiV2PidDepartureboardsGet
         */
        airCondition?: boolean
    
        //preferredTimezone
        /**
         * Preferred timezone offset as defined in the IANA Time zone database in the form of Country/City (use an URL encoded slash sign &#x60;%2F&#x60; or use an underscore _ symbol), default is Europe/Prague
         * @type {string}
         * @memberof PIDDepartureBoardsV2ApiV2PidDepartureboardsGet
         */
        preferredTimezone?: string
    
        //mode
        /**
         * Valid entries: &#x60;departures&#x60; (default), &#x60;arrivals&#x60;, &#x60;mixed&#x60;. Set how to handle behaviour in end stops. &#x60;departures&#x60; (default) returns all connections that depart from selected stops (does not return connections for which it is the final stop). &#x60;arrivals&#x60; returns all connections that arrive into the stops (does not return connections for which it is the first stop). &#x60;mixed&#x60; returns everything. Use &#x60;arrivals&#x60; to create dedicated arrival boards. Use &#x60;departures&#x60; for all other cases. Using &#x60;mixed&#x60; is not recomended as departures of adjoined routes will be returned twice.
         * @type {string}
         * @memberof PIDDepartureBoardsV2ApiV2PidDepartureboardsGet
         */
        mode?: string
    
        //order
        /**
         * Valid entries: &#x60;real&#x60; (default), &#x60;timetable&#x60;. Order results by predicted time including trip delay or by timetable time.
         * @type {string}
         * @memberof PIDDepartureBoardsV2ApiV2PidDepartureboardsGet
         */
        order?: string
    
        //filter
        /**
         * Valid entries: &#x60;none&#x60; (default), &#x60;routeOnce&#x60;, &#x60;routeOnceFill&#x60;, &#x60;routeHeadingOnce&#x60;, &#x60;routeHeadingOnceFill&#x60;, &#x60;routeHeadingOnceNoGap&#x60;, &#x60;routeHeadingOnceNoGapFill&#x60;. Defines how should be the list of departures returned. &#x60;none&#x60; returns all departures within the time and item limit. &#x60;routeOnce&#x60; returns exactly one occurence of departure for each &#x60;route_id&#x60;. Works best when querying a single stop. &#x60;routeHeadingOnce&#x60; returns one entry for each pair of &#x60;route_id&#x60; and &#x60;trip_headsign&#x60;, i.e. returns departures for routes that have multiple end stops. Works well when quering one or more stops in a node. &#x60;...NoGap&#x60; will ensure that departures with a distinct trip headsign will not be displayed if they should arrive too far in the future. &#x60;...Fill&#x60; attributes will behave the same as their namesakes but afterwards will fill the rest of request up to &#x60;total/limit&#x60; with further departures. Use to have every line/destination represented and have the display filled with departures at the same time.
         * @type {string}
         * @memberof PIDDepartureBoardsV2ApiV2PidDepartureboardsGet
         */
        filter?: string
    
        //skipisEnumSkipEnum
        /**
         * Filters out trips matching the given states. Multiple filters can be applied using array syntax, e.g., &#x60;&amp;skip[]&#x3D;canceled&amp;skip[]&#x3D;atStop&#x60;. Using both &#x60;untracked&#x60; and &#x60;missing&#x60; will exclude all untracked vehicles, as missing vehicles are a subset of untracked vehicles. We recommend using &#x60;missing&#x60; instead of &#x60;untracked&#x60;, as skipping all untracked vehicles may result in departures not appearing in the API response until the last few minutes before departure, especially for departure boards near the starting station/stop. 
         * @type {'canceled' | 'atStop' | 'untracked' | 'missing'}
         * @memberof PIDDepartureBoardsV2ApiV2PidDepartureboardsGet
         */
        skip?: V2PidDepartureboardsGetSkipEnum
    
        //limit
        /**
         * Limits the number of items in response. The maximum is 1000 (default value is 20).
         * @type {number}
         * @memberof PIDDepartureBoardsV2ApiV2PidDepartureboardsGet
         */
        limit?: number
    
        //total
        /**
         * Sets the number of items that will be queried. Use in conjunction with &#x60;offset&#x60;. Up to &#x60;total - offset&#x60;, but not more than &#x60;limit&#x60; items will be then returned. If unset, is same as &#x60;limit&#x60;. The maximum is 1000 (default value is 20).
         * @type {number}
         * @memberof PIDDepartureBoardsV2ApiV2PidDepartureboardsGet
         */
        total?: number
    
        //offset
        /**
         * Number of the initial departures that are skipped. Useful for multi-page displays.
         * @type {number}
         * @memberof PIDDepartureBoardsV2ApiV2PidDepartureboardsGet
         */
        offset?: number
    }
    
    
    
    
    
    
    
    
    /**
     * PIDDepartureBoardsV2Api - object-oriented interface
     * @export
     * @class PIDDepartureBoardsV2Api
     * @extends {BaseAPI}
     */
    export class PIDDepartureBoardsV2Api extends BaseAPI {
    
        constructor(protected override configuration: GolemioPublicTransportApiConfiguration, protected override axios: AxiosInstance = globalAxios) {
            super(configuration, configuration.basePath, axios);
        }
    
        /**
         * You have to use query parameters `ids`, `cisIds`, `aswIds` or `names` in array format - eg. `ids[]=1&ids[]=3`. **At least one of these IDs is required.** The maximum is 100 stops combined in one request.
         * @summary GET Departure Boards
    
         * @param {PIDDepartureBoardsV2ApiV2PidDepartureboardsGetQueryParams} queryParams Query parameters.
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof PIDDepartureBoardsV2Api
         */
        
        public async v2PidDepartureboardsGet(
            queryParams: PIDDepartureBoardsV2ApiV2PidDepartureboardsGetQueryParams = {},
            options: AxiosRequestConfig = {}
        ) {
    
            const localVarPath = `/v2/pid/departureboards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
            if (queryParams.ids !== undefined) {
                requestQueryParameter['ids'] = queryParams.ids;
            }
    
            if (queryParams.aswIds !== undefined) {
                requestQueryParameter['aswIds'] = queryParams.aswIds;
            }
    
            if (queryParams.cisIds !== undefined) {
                requestQueryParameter['cisIds'] = queryParams.cisIds;
            }
    
            if (queryParams.names !== undefined) {
                requestQueryParameter['names'] = queryParams.names;
            }
    
            if (queryParams.minutesBefore !== undefined) {
                requestQueryParameter['minutesBefore'] = queryParams.minutesBefore;
            }
    
            if (queryParams.minutesAfter !== undefined) {
                requestQueryParameter['minutesAfter'] = queryParams.minutesAfter;
            }
    
            if (queryParams.timeFrom !== undefined) {
                requestQueryParameter['timeFrom'] = queryParams.timeFrom;
            }
    
            if (queryParams.includeMetroTrains !== undefined) {
                requestQueryParameter['includeMetroTrains'] = queryParams.includeMetroTrains;
            }
    
            if (queryParams.airCondition !== undefined) {
                requestQueryParameter['airCondition'] = queryParams.airCondition;
            }
    
            if (queryParams.preferredTimezone !== undefined) {
                requestQueryParameter['preferredTimezone'] = queryParams.preferredTimezone;
            }
    
            if (queryParams.mode !== undefined) {
                requestQueryParameter['mode'] = queryParams.mode;
            }
    
            if (queryParams.order !== undefined) {
                requestQueryParameter['order'] = queryParams.order;
            }
    
            if (queryParams.filter !== undefined) {
                requestQueryParameter['filter'] = queryParams.filter;
            }
    
            if (queryParams.skip !== undefined) {
                requestQueryParameter['skip'] = queryParams.skip;
            }
    
            if (queryParams.limit !== undefined) {
                requestQueryParameter['limit'] = queryParams.limit;
            }
    
            if (queryParams.total !== undefined) {
                requestQueryParameter['total'] = queryParams.total;
            }
    
            if (queryParams.offset !== undefined) {
                requestQueryParameter['offset'] = queryParams.offset;
            }
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<PIDDepartureBoard>(axiosRequestConfig);
        }
    
        /**
         * 
         * @summary GET Infotexts (export from the legacy VYMI system)
    
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof PIDDepartureBoardsV2Api
         */
        
        public async v2PidInfotextsGet(
            options: AxiosRequestConfig = {}
        ) {
    
            const localVarPath = `/v2/pid/infotexts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<Array<V2PidInfotextsGet200ResponseInner>>(axiosRequestConfig);
        }
    }
    
        
        
    
    
    
    
    
    
    /**
     * Query parameters for v3PidTransferboardsGet operation in PIDDepartureBoardsV3Api.
     * @export
     * @interface PIDDepartureBoardsV3ApiV3PidTransferboardsGetQueryParams
     */
    export interface PIDDepartureBoardsV3ApiV3PidTransferboardsGetQueryParams {
        //cisId
        /**
         * CIS identifier of the stop. A list of CIS IDs can be found in [Prague Open data](https://opendata.praha.eu/datasets/https%3A%2F%2Fapi.opendata.praha.eu%2Flod%2Fcatalog%2F6ac8381f-ea19-4ea9-8949-92076809dc5a).
         * @type {number}
         * @memberof PIDDepartureBoardsV3ApiV3PidTransferboardsGet
         */
        cisId: number
    
        //tripNumber
        /**
         * Trip number of the vehicle in which the transfer is planned. Use to filter out transfers for a specific trip. Represents the numeric part of the GTFS &#x60;trip_short_name&#x60; (Os 2547 -&gt; 2547).
         * @type {number}
         * @memberof PIDDepartureBoardsV3ApiV3PidTransferboardsGet
         */
        tripNumber?: number
    
        //timeFrom
        /**
         * Set initial timestamp for time interval given by &#x60;minutesBefore&#x60; (hardcoded to 0) and &#x60;minutesAfter&#x60; (hardcoded to 60). Use to simulate query time different from now. Use ISO 8601 time format and URL encoded symbols - &#x60;%3A&#x60; for &#x60;:&#x60;, &#x60;%2B&#x60; for &#x60;.&#x60;, &#x60;%2F&#x60; for &#x60;+&#x60;. Time zone is set to &#x60;Europe/Prague&#x60;. Applicable range is -6 hours +2 days from now.
         * @type {string}
         * @memberof PIDDepartureBoardsV3ApiV3PidTransferboardsGet
         */
        timeFrom?: string
    }
    
    
    
    
    /**
     * PIDDepartureBoardsV3Api - object-oriented interface
     * @export
     * @class PIDDepartureBoardsV3Api
     * @extends {BaseAPI}
     */
    export class PIDDepartureBoardsV3Api extends BaseAPI {
    
        constructor(protected override configuration: GolemioPublicTransportApiConfiguration, protected override axios: AxiosInstance = globalAxios) {
            super(configuration, configuration.basePath, axios);
        }
    
        /**
         * 
         * @summary GET Infotexts (export from the VYMI (JIS) Infotexts system)
    
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof PIDDepartureBoardsV3Api
         */
        
        public async v3PidInfotextsGet(
            options: AxiosRequestConfig = {}
        ) {
    
            const localVarPath = `/v3/pid/infotexts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<Array<V3PidInfotextsGet200ResponseInner>>(axiosRequestConfig);
        }
    
        /**
         * ‚ö†Ô∏è Note: This endpoint is experimental and may be subject to change. Tested and optimized for train transfers only (as in transfering from a train to other all kinds of transport). 
         * @summary GET Transfer Boards
    
         * @param {PIDDepartureBoardsV3ApiV3PidTransferboardsGetQueryParams} queryParams Query parameters.
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof PIDDepartureBoardsV3Api
         */
        
        public async v3PidTransferboardsGet(
            queryParams: PIDDepartureBoardsV3ApiV3PidTransferboardsGetQueryParams,
            options: AxiosRequestConfig = {}
        ) {
    
            // verify required parameter 'cisId' is not null or undefined
            assertParamExists('v3PidTransferboardsGet', 'cisId', queryParams.cisId)
            
            const localVarPath = `/v3/pid/transferboards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
            if (queryParams.cisId !== undefined) {
                requestQueryParameter['cisId'] = queryParams.cisId;
            }
    
            if (queryParams.tripNumber !== undefined) {
                requestQueryParameter['tripNumber'] = queryParams.tripNumber;
            }
    
            if (queryParams.timeFrom !== undefined) {
                requestQueryParameter['timeFrom'] = queryParams.timeFrom;
            }
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<V3PidTransferboardsGet200Response>(axiosRequestConfig);
        }
    }
    
        
        
    
    
    
    
    
    /**
     * PIDDepartureBoardsV3InternalApi - object-oriented interface
     * @export
     * @class PIDDepartureBoardsV3InternalApi
     * @extends {BaseAPI}
     */
    export class PIDDepartureBoardsV3InternalApi extends BaseAPI {
    
        constructor(protected override configuration: GolemioPublicTransportApiConfiguration, protected override axios: AxiosInstance = globalAxios) {
            super(configuration, configuration.basePath, axios);
        }
    
        /**
         * 
         * @summary Get ROPID departures presets linked with gtfs stops
    
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof PIDDepartureBoardsV3InternalApi
         */
        
        public async v3PidDeparturepresetsGet(
            options: AxiosRequestConfig = {}
        ) {
    
            const localVarPath = `/v3/pid/departurepresets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<Array<V3PidDeparturepresetsGet200ResponseInner>>(axiosRequestConfig);
        }
    }
    
        
        
    /**
     * @export
     */
    export const V4PidTransferboardsGetRouteTypeEnum = {
        NUMBER_0: 0,
        NUMBER_1: 1,
        NUMBER_2: 2,
        NUMBER_3: 3,
        NUMBER_4: 4,
        NUMBER_7: 7,
        NUMBER_11: 11
    } as const;
    export type V4PidTransferboardsGetRouteTypeEnum = typeof V4PidTransferboardsGetRouteTypeEnum[keyof typeof V4PidTransferboardsGetRouteTypeEnum];
    
    
    /**
     * Query parameters for v4PidTransferboardsGet operation in PIDDepartureBoardsV4Api.
     * @export
     * @interface PIDDepartureBoardsV4ApiV4PidTransferboardsGetQueryParams
     */
    export interface PIDDepartureBoardsV4ApiV4PidTransferboardsGetQueryParams {
        //cisId
        /**
         * CIS identifier of the stop or node. A list of CIS IDs can be found in [Prague Open data](https://opendata.praha.eu/datasets/https%3A%2F%2Fapi.opendata.praha.eu%2Flod%2Fcatalog%2F6ac8381f-ea19-4ea9-8949-92076809dc5a). Includes departures from all stops at the given CIS ID. Required if &#x60;aswId&#x60; is not provided. Only one of &#x60;cisId&#x60; or &#x60;aswId&#x60; can be used. 
         * @type {number}
         * @memberof PIDDepartureBoardsV4ApiV4PidTransferboardsGet
         */
        cisId?: number
    
        //aswId
        /**
         * ASW identifier of the stop. The format is &#x60;nodeId/stopId&#x60; where stopId is not mandatory. You can use &#x60;_&#x60; instead of &#x60;/&#x60; or encode the slash sign with &#x60;%2F&#x60;,  Includes departures from the given stop, plus from all stops at the given node (1330_1 -&gt; 1330 -&gt; 1330_1, 1330_2, ...), plus from all stops sharing the same name. Departures from associated metro and train stations are also included (Na Kn√≠≈æec√≠ -&gt; Andƒõl). Required if &#x60;cisId&#x60; is not provided. Only one of &#x60;cisId&#x60; or &#x60;aswId&#x60; can be used. 
         * @type {string}
         * @memberof PIDDepartureBoardsV4ApiV4PidTransferboardsGet
         */
        aswId?: string
    
        //tripNumber
        /**
         * Trip number of the vehicle in which the transfer is planned. Use to filter out transfers for a specific trip. Represents the numeric part of the GTFS &#x60;trip_short_name&#x60; (&#x60;Os 2547&#x60; -&gt; &#x60;2547&#x60;). Generally, &#x60;trip_short_name&#x60; is available only for train services. Required if &#x60;vehicleRegistrationNumber&#x60; is not provided. Only one of &#x60;tripNumber&#x60; or &#x60;vehicleRegistrationNumber&#x60; can be used. 
         * @type {number}
         * @memberof PIDDepartureBoardsV4ApiV4PidTransferboardsGet
         */
        tripNumber?: number
    
        //vehicleRegistrationNumber
        /**
         * Registration number of the vehicle in which the transfer is planned. Use to filter out transfers for a specific vehicle. Required if &#x60;tripNumber&#x60; is not provided. Only one of &#x60;tripNumber&#x60; or &#x60;vehicleRegistrationNumber&#x60; can be used. 
         * @type {string}
         * @memberof PIDDepartureBoardsV4ApiV4PidTransferboardsGet
         */
        vehicleRegistrationNumber?: string
    
        //routeTypeisEnumRouteTypeEnum
        /**
         * Transport type of the route in which the transfer is planned. This parameter is required to distinguish between different vehicle types, as trams and buses can share the same registration number. The value is represented by the following enum from GTFS: - 0: Tram - 1: Subway - 2: Train - 3: Bus - 4: Ferry - 7: Funicular - 11: Trolleybus For example, if you want to get a tram with registration number \&quot;1001\&quot;, use routeType&#x3D;0. For a bus with the same registration number, use routeType&#x3D;3. 
         * @type {0 | 1 | 2 | 3 | 4 | 7 | 11}
         * @memberof PIDDepartureBoardsV4ApiV4PidTransferboardsGet
         */
        routeType: V4PidTransferboardsGetRouteTypeEnum
    
        //timeFrom
        /**
         * Set initial timestamp for time interval given by &#x60;minutesBefore&#x60; (hardcoded to 0) and &#x60;minutesAfter&#x60; (hardcoded to 60). Use to simulate query time different from now. Use ISO 8601 time format and URL encoded symbols - &#x60;%3A&#x60; for &#x60;:&#x60;, &#x60;%2B&#x60; for &#x60;.&#x60;, &#x60;%2F&#x60; for &#x60;+&#x60;. Time zone is set to &#x60;Europe/Prague&#x60;. Applicable range is -6 hours +2 days from now. 
         * @type {string}
         * @memberof PIDDepartureBoardsV4ApiV4PidTransferboardsGet
         */
        timeFrom?: string
    
        //limit
        /**
         * Limit the number of rows of departures returned. The total number of departures is a union across individual types of departures. The default value is 8. 
         * @type {number}
         * @memberof PIDDepartureBoardsV4ApiV4PidTransferboardsGet
         */
        limit?: number
    }
    
    
    
    
    /**
     * PIDDepartureBoardsV4Api - object-oriented interface
     * @export
     * @class PIDDepartureBoardsV4Api
     * @extends {BaseAPI}
     */
    export class PIDDepartureBoardsV4Api extends BaseAPI {
    
        constructor(protected override configuration: GolemioPublicTransportApiConfiguration, protected override axios: AxiosInstance = globalAxios) {
            super(configuration, configuration.basePath, axios);
        }
    
        /**
         * 
         * @summary GET Transfer Boards
    
         * @param {PIDDepartureBoardsV4ApiV4PidTransferboardsGetQueryParams} queryParams Query parameters.
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof PIDDepartureBoardsV4Api
         */
        
        public async v4PidTransferboardsGet(
            queryParams: PIDDepartureBoardsV4ApiV4PidTransferboardsGetQueryParams,
            options: AxiosRequestConfig = {}
        ) {
    
            // verify required parameter 'routeType' is not null or undefined
            assertParamExists('v4PidTransferboardsGet', 'routeType', queryParams.routeType)
            
            const localVarPath = `/v4/pid/transferboards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
            if (queryParams.cisId !== undefined) {
                requestQueryParameter['cisId'] = queryParams.cisId;
            }
    
            if (queryParams.aswId !== undefined) {
                requestQueryParameter['aswId'] = queryParams.aswId;
            }
    
            if (queryParams.tripNumber !== undefined) {
                requestQueryParameter['tripNumber'] = queryParams.tripNumber;
            }
    
            if (queryParams.vehicleRegistrationNumber !== undefined) {
                requestQueryParameter['vehicleRegistrationNumber'] = queryParams.vehicleRegistrationNumber;
            }
    
            if (queryParams.routeType !== undefined) {
                requestQueryParameter['routeType'] = queryParams.routeType;
            }
    
            if (queryParams.timeFrom !== undefined) {
                requestQueryParameter['timeFrom'] = queryParams.timeFrom;
            }
    
            if (queryParams.limit !== undefined) {
                requestQueryParameter['limit'] = queryParams.limit;
            }
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<V4PidTransferboardsGet200Response>(axiosRequestConfig);
        }
    }
    
        
        
    /**
     * @export
     */
    export const V2VehiclepositionsGetAcceptEncodingEnum = {
        Gzip: 'gzip',
        Identity: 'identity'
    } as const;
    export type V2VehiclepositionsGetAcceptEncodingEnum = typeof V2VehiclepositionsGetAcceptEncodingEnum[keyof typeof V2VehiclepositionsGetAcceptEncodingEnum];
    
    
    /**
     * Query parameters for v2VehiclepositionsGet operation in PIDRealtimePositionsV2Api.
     * @export
     * @interface PIDRealtimePositionsV2ApiV2VehiclepositionsGetQueryParams
     */
    export interface PIDRealtimePositionsV2ApiV2VehiclepositionsGetQueryParams {
        //limit
        /**
         * Limits number of retrieved items. The maximum is 10000.
         * @type {number}
         * @memberof PIDRealtimePositionsV2ApiV2VehiclepositionsGet
         */
        limit?: number
    
        //offset
        /**
         * Number of the first items that are skipped.
         * @type {number}
         * @memberof PIDRealtimePositionsV2ApiV2VehiclepositionsGet
         */
        offset?: number
    
        //includeNotTracking
        /**
         * Enrich result dataset with not tracking trip (those trips not being on track - before and after trip)
         * @type {boolean}
         * @memberof PIDRealtimePositionsV2ApiV2VehiclepositionsGet
         */
        includeNotTracking?: boolean
    
        //includeNotPublic
        /**
         * Enrich result dataset with not public trips (trips without run schedule)
         * @type {boolean}
         * @memberof PIDRealtimePositionsV2ApiV2VehiclepositionsGet
         */
        includeNotPublic?: boolean
    
        //cisTripNumber
        /**
         * Filter result by CIS trip number
         * @type {number}
         * @memberof PIDRealtimePositionsV2ApiV2VehiclepositionsGet
         */
        cisTripNumber?: number
    
        //preferredTimezone
        /**
         * Preferred timezone offset by given Country/City (use encoded slash sign with &#x60;%2F&#x60; or use &#x60;_&#x60; sign)
         * @type {string}
         * @memberof PIDRealtimePositionsV2ApiV2VehiclepositionsGet
         */
        preferredTimezone?: string
    
        //routeId
        /**
         * Filter result by route id
         * @type {string}
         * @memberof PIDRealtimePositionsV2ApiV2VehiclepositionsGet
         */
        routeId?: string
    
        //routeShortName
        /**
         * Filter result by short name
         * @type {string}
         * @memberof PIDRealtimePositionsV2ApiV2VehiclepositionsGet
         */
        routeShortName?: string
    
        //updatedSince
        /**
         * Limit results to the ones updated after (timestamp greater than)
         * @type {string}
         * @memberof PIDRealtimePositionsV2ApiV2VehiclepositionsGet
         */
        updatedSince?: string
    }
    
    
    /**
     * Header parameters for v2VehiclepositionsGet operation in PIDRealtimePositionsV2Api.
     * @export
     * @interface PIDRealtimePositionsV2ApiV2VehiclepositionsGetHeaderParams
     */
    export interface PIDRealtimePositionsV2ApiV2VehiclepositionsGetHeaderParams {
        /**
         * Indicate the content encoding (usually a compression algorithm) that the client can understand. See [mdn](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding) for more details. Note that for this endpoint, if no value is given, gzip compression will be used by default (the &#x60;identity&#x60; value can be used to opt out of the default compression).
         * @type {'gzip' | 'identity'}
         * @memberof PIDRealtimePositionsV2ApiV2VehiclepositionsGet
         */
        acceptEncoding?: V2VehiclepositionsGetAcceptEncodingEnum
    }
    
    
    /**
     * @export
     */
    export const V2VehiclepositionsGtfsTripIdGetAcceptEncodingEnum = {
        Gzip: 'gzip',
        Identity: 'identity'
    } as const;
    export type V2VehiclepositionsGtfsTripIdGetAcceptEncodingEnum = typeof V2VehiclepositionsGtfsTripIdGetAcceptEncodingEnum[keyof typeof V2VehiclepositionsGtfsTripIdGetAcceptEncodingEnum];
    
    
    /**
     * Query parameters for v2VehiclepositionsGtfsTripIdGet operation in PIDRealtimePositionsV2Api.
     * @export
     * @interface PIDRealtimePositionsV2ApiV2VehiclepositionsGtfsTripIdGetQueryParams
     */
    export interface PIDRealtimePositionsV2ApiV2VehiclepositionsGtfsTripIdGetQueryParams {
        //includeNotTracking
        /**
         * Enrich result dataset with not tracking trip (last tracked vehicle after its trip)
         * @type {boolean}
         * @memberof PIDRealtimePositionsV2ApiV2VehiclepositionsGtfsTripIdGet
         */
        includeNotTracking?: boolean
    
        //includePositions
        /**
         * Enrich result dataset with positions
         * @type {boolean}
         * @memberof PIDRealtimePositionsV2ApiV2VehiclepositionsGtfsTripIdGet
         */
        includePositions?: boolean
    
        //preferredTimezone
        /**
         * Preferred timezone offset by given Country/City (use encoded slash sign by %2F or use _ sign)
         * @type {string}
         * @memberof PIDRealtimePositionsV2ApiV2VehiclepositionsGtfsTripIdGet
         */
        preferredTimezone?: string
    }
    
    
    /**
     * Header parameters for v2VehiclepositionsGtfsTripIdGet operation in PIDRealtimePositionsV2Api.
     * @export
     * @interface PIDRealtimePositionsV2ApiV2VehiclepositionsGtfsTripIdGetHeaderParams
     */
    export interface PIDRealtimePositionsV2ApiV2VehiclepositionsGtfsTripIdGetHeaderParams {
        /**
         * Indicate the content encoding (usually a compression algorithm) that the client can understand. See [mdn](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding) for more details. Note that for this endpoint, if no value is given, gzip compression will be used by default (the &#x60;identity&#x60; value can be used to opt out of the default compression).
         * @type {'gzip' | 'identity'}
         * @memberof PIDRealtimePositionsV2ApiV2VehiclepositionsGtfsTripIdGet
         */
        acceptEncoding?: V2VehiclepositionsGtfsTripIdGetAcceptEncodingEnum
    }
    
    
    
    /**
     * PIDRealtimePositionsV2Api - object-oriented interface
     * @export
     * @class PIDRealtimePositionsV2Api
     * @extends {BaseAPI}
     */
    export class PIDRealtimePositionsV2Api extends BaseAPI {
    
        constructor(protected override configuration: GolemioPublicTransportApiConfiguration, protected override axios: AxiosInstance = globalAxios) {
            super(configuration, configuration.basePath, axios);
        }
    
        /**
         * Positions in one the following states are included by default: - `at_stop` - The position is tracking and the closest anchor point or metro rail track segment is a stop. - `on_track` - The position is tracking, but is neither `at_stop` nor `off_track`.  Using the `includeNotTracking` parameter, positions in one the following states can be additionally included: - `after_track` - The position is not tracking and the trip\'s last known position is tracking. For metro positions, this can also mean that it is tracking, the vehicle is 200+ meters from the closest metro rail track segment of its track and the vehicle\'s message attributes `tm` and `odch` or higher than the arrival to the final stop. For other positions from TCP sources (DPP buses and trams), this can also mean that it is tracking and the vehicle sent a message while at the final stop or sent a message with the `tjr` attribute higher than the arrival to the final stop. - `after_track_delayed` - The same as `after_track`, but the position always has defined delay (not null) if possible to deduct from GTFS static data and origin timestamp. Essentially, it means the vehicle is `at_stop` at the very last stop of the trip. The delay is also propagated to the next trip of the vehicle, unlike the `after_track` state. - `before_track` - The position is not tracking and either the trip\'s previous position is not known, or the previous position\'s state is `at_stop` or `on_track`. - `before_track_delayed` - The position has a delay prediction based on the vehicle\'s previous trip. - `canceled` - The position is canceled. - `off_track` - The position is tracking and the vehicle is 200+ meters from the closest anchor point or metro rail track segment of its track. For metro positions, it is additionally required that the vehicle\'s message attributes `tm` and `odch` or less than or equal to the arrival to the final stop.  Using the `includeNotPublic` parameter, positions in the following state can be additionally included: - `not_public` - The position belongs to a non-public trip (trip without run schedule).  The following states also exist internally but are excluded from the API output: - `duplicate` - The position is not tracking, the trip\'s last known position is tracking and there is another position with identical `origin_timestamp`. - `invisible` - The position is not tracking and either:     - the trip\'s previous position is not known or the previous position\'s state is `at_stop` or `on_track`, and the vehicle is on its way from the garage;     - or the trip\'s last known position is tracking and the vehicle is on its way to the garage. - `mismatched` - The position does not make sense (e.g. it was sent late and thus has a mismatched stop sequence). - `unknown` - The position is not yet processed (or was determined to never be processed) or has been invalidated (e.g. due to a vehicle repeating some part of the trip). 
         * @summary GET All Vehicle Positions
    
         * @param {PIDRealtimePositionsV2ApiV2VehiclepositionsGetQueryParams} queryParams Query parameters.
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof PIDRealtimePositionsV2Api
         */
        
        public async v2VehiclepositionsGet(
            queryParams: PIDRealtimePositionsV2ApiV2VehiclepositionsGetQueryParams = {},
            headerParams: PIDRealtimePositionsV2ApiV2VehiclepositionsGetHeaderParams = {},
            options: AxiosRequestConfig = {}
        ) {
    
            const localVarPath = `/v2/vehiclepositions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
            if (queryParams.limit !== undefined) {
                requestQueryParameter['limit'] = queryParams.limit;
            }
    
            if (queryParams.offset !== undefined) {
                requestQueryParameter['offset'] = queryParams.offset;
            }
    
            if (queryParams.includeNotTracking !== undefined) {
                requestQueryParameter['includeNotTracking'] = queryParams.includeNotTracking;
            }
    
            if (queryParams.includeNotPublic !== undefined) {
                requestQueryParameter['includeNotPublic'] = queryParams.includeNotPublic;
            }
    
            if (queryParams.cisTripNumber !== undefined) {
                requestQueryParameter['cisTripNumber'] = queryParams.cisTripNumber;
            }
    
            if (queryParams.preferredTimezone !== undefined) {
                requestQueryParameter['preferredTimezone'] = queryParams.preferredTimezone;
            }
    
            if (queryParams.routeId !== undefined) {
                requestQueryParameter['routeId'] = queryParams.routeId;
            }
    
            if (queryParams.routeShortName !== undefined) {
                requestQueryParameter['routeShortName'] = queryParams.routeShortName;
            }
    
            if (queryParams.updatedSince !== undefined) {
                requestQueryParameter['updatedSince'] = queryParams.updatedSince;
            }
    
            if (headerParams.acceptEncoding != null) {
                requestHeaderParameter['Accept-Encoding'] = String(headerParams.acceptEncoding);
            }
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<V2VehiclepositionsGet200Response>(axiosRequestConfig);
        }
    
        /**
         * 
         * @summary GET Vehicle Position
    
         * @param {string} gtfsTripId Filter result by trip id (gtfs_trip_id)
         * @param {PIDRealtimePositionsV2ApiV2VehiclepositionsGtfsTripIdGetQueryParams} queryParams Query parameters.
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof PIDRealtimePositionsV2Api
         */
        
        public async v2VehiclepositionsGtfsTripIdGet(
            gtfsTripId: string,
            queryParams: PIDRealtimePositionsV2ApiV2VehiclepositionsGtfsTripIdGetQueryParams,
            headerParams: PIDRealtimePositionsV2ApiV2VehiclepositionsGtfsTripIdGetHeaderParams,
            options: AxiosRequestConfig = {}
        ) {
    
            // verify required parameter 'gtfsTripId' is not null or undefined
            assertParamExists('v2VehiclepositionsGtfsTripIdGet', 'gtfsTripId', gtfsTripId)
            
            const localVarPath = `/v2/vehiclepositions/{gtfsTripId}`
                .replace(`{${"gtfsTripId"}}`, encodeURIComponent(String(gtfsTripId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
            if (queryParams.includeNotTracking !== undefined) {
                requestQueryParameter['includeNotTracking'] = queryParams.includeNotTracking;
            }
    
            if (queryParams.includePositions !== undefined) {
                requestQueryParameter['includePositions'] = queryParams.includePositions;
            }
    
            if (queryParams.preferredTimezone !== undefined) {
                requestQueryParameter['preferredTimezone'] = queryParams.preferredTimezone;
            }
    
            if (headerParams.acceptEncoding != null) {
                requestHeaderParameter['Accept-Encoding'] = String(headerParams.acceptEncoding);
            }
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<V2VehiclepositionsGet200ResponseFeaturesInner>(axiosRequestConfig);
        }
    }
    
        
        
    /**
     * @export
     */
    export const V2PublicDepartureboardsGetAcceptEncodingEnum = {
        Gzip: 'gzip',
        Identity: 'identity'
    } as const;
    export type V2PublicDepartureboardsGetAcceptEncodingEnum = typeof V2PublicDepartureboardsGetAcceptEncodingEnum[keyof typeof V2PublicDepartureboardsGetAcceptEncodingEnum];
    
    
    /**
     * Query parameters for v2PublicDepartureboardsGet operation in PublicDeparturesV2Api.
     * @export
     * @interface PublicDeparturesV2ApiV2PublicDepartureboardsGetQueryParams
     */
    export interface PublicDeparturesV2ApiV2PublicDepartureboardsGetQueryParams {
        //stopIds
        /**
         * Groups of stop IDs formatted as JSON (index/priority -&gt; stop IDs). For example ?stopIds[]&#x3D;{\\\&quot;0\\\&quot;: [\\\&quot;U717Z5P\\\&quot;]}&amp;stopIds[]&#x3D;{\\\&quot;1\\\&quot;: [\\\&quot;U718Z5P\\\&quot;, \\\&quot;U719Z5P\\\&quot;]}. The maximum number of groups is 50. The maximum number of stops in one group is 50. The maximum number of stops combined is 50. 
         * @type {Array<string>}
         * @memberof PublicDeparturesV2ApiV2PublicDepartureboardsGet
         */
        stopIds: Array<string>
    
        //limit
        /**
         * Limit for each group of departures. Default is 5. Maximum is 30.
         * @type {number}
         * @memberof PublicDeparturesV2ApiV2PublicDepartureboardsGet
         */
        limit?: number
    
        //routeShortNames
        /**
         * Default is null
         * @type {Array<string>}
         * @memberof PublicDeparturesV2ApiV2PublicDepartureboardsGet
         */
        routeShortNames?: Array<string>
    
        //minutesAfter
        /**
         * Default is 60. Maximum is 360 (6 hours)
         * @type {number}
         * @memberof PublicDeparturesV2ApiV2PublicDepartureboardsGet
         */
        minutesAfter?: number
    }
    
    
    /**
     * Header parameters for v2PublicDepartureboardsGet operation in PublicDeparturesV2Api.
     * @export
     * @interface PublicDeparturesV2ApiV2PublicDepartureboardsGetHeaderParams
     */
    export interface PublicDeparturesV2ApiV2PublicDepartureboardsGetHeaderParams {
        /**
         * Indicate the content encoding (usually a compression algorithm) that the client can understand. See [mdn](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding) for more details. Note that for this endpoint, if no value is given, gzip compression will be used by default (the &#x60;identity&#x60; value can be used to opt out of the default compression).
         * @type {'gzip' | 'identity'}
         * @memberof PublicDeparturesV2ApiV2PublicDepartureboardsGet
         */
        acceptEncoding?: V2PublicDepartureboardsGetAcceptEncodingEnum
    }
    
    
    
    /**
     * PublicDeparturesV2Api - object-oriented interface
     * @export
     * @class PublicDeparturesV2Api
     * @extends {BaseAPI}
     */
    export class PublicDeparturesV2Api extends BaseAPI {
    
        constructor(protected override configuration: GolemioPublicTransportApiConfiguration, protected override axios: AxiosInstance = globalAxios) {
            super(configuration, configuration.basePath, axios);
        }
    
        /**
         * ‚ÑπÔ∏è Note: This endpoint is optimized for client applications serving many users simultaneously. It provides streamlined data structures and caching strategies suitable for client-side consumption. Rate limits can be adjusted upon request - contact us if you need higher limits. Note: Despite the \'public\' prefix, this endpoint requires an API key for access control and usage monitoring. 
         * @summary Get Departure Boards
    
         * @param {PublicDeparturesV2ApiV2PublicDepartureboardsGetQueryParams} queryParams Query parameters.
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof PublicDeparturesV2Api
         */
        
        public async v2PublicDepartureboardsGet(
            queryParams: PublicDeparturesV2ApiV2PublicDepartureboardsGetQueryParams,
            headerParams: PublicDeparturesV2ApiV2PublicDepartureboardsGetHeaderParams,
            options: AxiosRequestConfig = {}
        ) {
    
            // verify required parameter 'stopIds' is not null or undefined
            assertParamExists('v2PublicDepartureboardsGet', 'stopIds', queryParams.stopIds)
            
            const localVarPath = `/v2/public/departureboards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
            if (queryParams.stopIds) {
                requestQueryParameter['stopIds'] = queryParams.stopIds;
            }
    
            if (queryParams.limit !== undefined) {
                requestQueryParameter['limit'] = queryParams.limit;
            }
    
            if (queryParams.routeShortNames) {
                requestQueryParameter['routeShortNames'] = queryParams.routeShortNames;
            }
    
            if (queryParams.minutesAfter !== undefined) {
                requestQueryParameter['minutesAfter'] = queryParams.minutesAfter;
            }
    
            if (headerParams.acceptEncoding != null) {
                requestHeaderParameter['Accept-Encoding'] = String(headerParams.acceptEncoding);
            }
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<Array<Array<PublicDepartureGroupInner>>>(axiosRequestConfig);
        }
    }
    
        
        
    /**
     * @export
     */
    export const V2PublicGtfsTripsGtfsTripIdGetScopesEnum = {
        Info: 'info',
        StopTimes: 'stop_times',
        Shapes: 'shapes',
        VehicleDescriptor: 'vehicle_descriptor'
    } as const;
    export type V2PublicGtfsTripsGtfsTripIdGetScopesEnum = typeof V2PublicGtfsTripsGtfsTripIdGetScopesEnum[keyof typeof V2PublicGtfsTripsGtfsTripIdGetScopesEnum];
    /**
     * @export
     */
    export const V2PublicGtfsTripsGtfsTripIdGetAcceptEncodingEnum = {
        Gzip: 'gzip',
        Identity: 'identity'
    } as const;
    export type V2PublicGtfsTripsGtfsTripIdGetAcceptEncodingEnum = typeof V2PublicGtfsTripsGtfsTripIdGetAcceptEncodingEnum[keyof typeof V2PublicGtfsTripsGtfsTripIdGetAcceptEncodingEnum];
    
    
    /**
     * Query parameters for v2PublicGtfsTripsGtfsTripIdGet operation in PublicGTFSStaticLookupV2Api.
     * @export
     * @interface PublicGTFSStaticLookupV2ApiV2PublicGtfsTripsGtfsTripIdGetQueryParams
     */
    export interface PublicGTFSStaticLookupV2ApiV2PublicGtfsTripsGtfsTripIdGetQueryParams {
        //scopesisEnumScopesEnum
        /**
         * Choose which scopes to include in response.
         * @type {Array<'info' | 'stop_times' | 'shapes' | 'vehicle_descriptor'>}
         * @memberof PublicGTFSStaticLookupV2ApiV2PublicGtfsTripsGtfsTripIdGet
         */
        scopes: Array<V2PublicGtfsTripsGtfsTripIdGetScopesEnum>
    }
    
    
    /**
     * Header parameters for v2PublicGtfsTripsGtfsTripIdGet operation in PublicGTFSStaticLookupV2Api.
     * @export
     * @interface PublicGTFSStaticLookupV2ApiV2PublicGtfsTripsGtfsTripIdGetHeaderParams
     */
    export interface PublicGTFSStaticLookupV2ApiV2PublicGtfsTripsGtfsTripIdGetHeaderParams {
        /**
         * Indicate the content encoding (usually a compression algorithm) that the client can understand. See [mdn](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding) for more details. Note that for this endpoint, if no value is given, gzip compression will be used by default (the &#x60;identity&#x60; value can be used to opt out of the default compression).
         * @type {'gzip' | 'identity'}
         * @memberof PublicGTFSStaticLookupV2ApiV2PublicGtfsTripsGtfsTripIdGet
         */
        acceptEncoding?: V2PublicGtfsTripsGtfsTripIdGetAcceptEncodingEnum
    }
    
    
    
    /**
     * PublicGTFSStaticLookupV2Api - object-oriented interface
     * @export
     * @class PublicGTFSStaticLookupV2Api
     * @extends {BaseAPI}
     */
    export class PublicGTFSStaticLookupV2Api extends BaseAPI {
    
        constructor(protected override configuration: GolemioPublicTransportApiConfiguration, protected override axios: AxiosInstance = globalAxios) {
            super(configuration, configuration.basePath, axios);
        }
    
        /**
         * Get GTFS static trip info by trip ID, including associated stop times (without no stop waypoints) and shapes.  ‚ÑπÔ∏è Note: This endpoint is optimized for client applications serving many users simultaneously. It provides streamlined data structures and caching strategies suitable for client-side consumption. Rate limits can be adjusted upon request - contact us if you need higher limits. Note: Despite the \'public\' prefix, this endpoint requires an API key for access control and usage monitoring. 
         * @summary GET GTFS Trip
    
         * @param {string} gtfsTripId Filter result by GTFS trip ID.
         * @param {PublicGTFSStaticLookupV2ApiV2PublicGtfsTripsGtfsTripIdGetQueryParams} queryParams Query parameters.
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof PublicGTFSStaticLookupV2Api
         */
        
        public async v2PublicGtfsTripsGtfsTripIdGet(
            gtfsTripId: string,
            queryParams: PublicGTFSStaticLookupV2ApiV2PublicGtfsTripsGtfsTripIdGetQueryParams,
            headerParams: PublicGTFSStaticLookupV2ApiV2PublicGtfsTripsGtfsTripIdGetHeaderParams,
            options: AxiosRequestConfig = {}
        ) {
    
            // verify required parameter 'gtfsTripId' is not null or undefined
            assertParamExists('v2PublicGtfsTripsGtfsTripIdGet', 'gtfsTripId', gtfsTripId)
            assertParamExists('v2PublicGtfsTripsGtfsTripIdGet', 'scopes', queryParams.scopes)
            
            // verify required parameter 'scopes' is not null or undefined
            assertParamExists('v2PublicGtfsTripsGtfsTripIdGet', 'gtfsTripId', gtfsTripId)
            assertParamExists('v2PublicGtfsTripsGtfsTripIdGet', 'scopes', queryParams.scopes)
            
            const localVarPath = `/v2/public/gtfs/trips/{gtfsTripId}`
                .replace(`{${"gtfsTripId"}}`, encodeURIComponent(String(gtfsTripId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
            if (queryParams.scopes) {
                requestQueryParameter['scopes'] = queryParams.scopes;
            }
    
            if (headerParams.acceptEncoding != null) {
                requestHeaderParameter['Accept-Encoding'] = String(headerParams.acceptEncoding);
            }
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<V2PublicGtfsTripsGtfsTripIdGet200Response>(axiosRequestConfig);
        }
    }
    
        
        
    /**
     * @export
     */
    export const V2PublicVehiclepositionsGetRouteTypeEnum = {
        Tram: 'tram',
        Metro: 'metro',
        Train: 'train',
        Bus: 'bus',
        Ferry: 'ferry',
        Funicular: 'funicular',
        Trolleybus: 'trolleybus'
    } as const;
    export type V2PublicVehiclepositionsGetRouteTypeEnum = typeof V2PublicVehiclepositionsGetRouteTypeEnum[keyof typeof V2PublicVehiclepositionsGetRouteTypeEnum];
    /**
     * @export
     */
    export const V2PublicVehiclepositionsGetAcceptEncodingEnum = {
        Gzip: 'gzip',
        Identity: 'identity'
    } as const;
    export type V2PublicVehiclepositionsGetAcceptEncodingEnum = typeof V2PublicVehiclepositionsGetAcceptEncodingEnum[keyof typeof V2PublicVehiclepositionsGetAcceptEncodingEnum];
    
    
    /**
     * Query parameters for v2PublicVehiclepositionsGet operation in PublicVehiclePositionsV2Api.
     * @export
     * @interface PublicVehiclePositionsV2ApiV2PublicVehiclepositionsGetQueryParams
     */
    export interface PublicVehiclePositionsV2ApiV2PublicVehiclepositionsGetQueryParams {
        //boundingBox
        /**
         * Filter by bounding box in format \&quot;topLeft.lat,topLeft.lon,bottomRight.lat,bottomRight.lon\&quot;. Latitude must be in range -90 to 90, longitude in range -180 to 180. Polygons that fit only partialy to selected bounding box are included 
         * @type {string}
         * @memberof PublicVehiclePositionsV2ApiV2PublicVehiclepositionsGet
         */
        boundingBox?: string
    
        //routeShortName
        /**
         * Filter by short name of route. URL: &#x60;?routeShortName&#x3D;381&amp;routeShortName&#x3D;X1&#x60;
         * @type {Array<string>}
         * @memberof PublicVehiclePositionsV2ApiV2PublicVehiclepositionsGet
         */
        routeShortName?: Array<string>
    
        //routeTypeisEnumRouteTypeEnum
        /**
         * filter by transport type
         * @type {Array<'tram' | 'metro' | 'train' | 'bus' | 'ferry' | 'funicular' | 'trolleybus'>}
         * @memberof PublicVehiclePositionsV2ApiV2PublicVehiclepositionsGet
         */
        routeType?: Array<V2PublicVehiclepositionsGetRouteTypeEnum>
    }
    
    
    /**
     * Header parameters for v2PublicVehiclepositionsGet operation in PublicVehiclePositionsV2Api.
     * @export
     * @interface PublicVehiclePositionsV2ApiV2PublicVehiclepositionsGetHeaderParams
     */
    export interface PublicVehiclePositionsV2ApiV2PublicVehiclepositionsGetHeaderParams {
        /**
         * Indicate the content encoding (usually a compression algorithm) that the client can understand. See [mdn](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding) for more details. Note that for this endpoint, if no value is given, gzip compression will be used by default (the &#x60;identity&#x60; value can be used to opt out of the default compression).
         * @type {'gzip' | 'identity'}
         * @memberof PublicVehiclePositionsV2ApiV2PublicVehiclepositionsGet
         */
        acceptEncoding?: V2PublicVehiclepositionsGetAcceptEncodingEnum
    }
    
    
    /**
     * @export
     */
    export const V2PublicVehiclepositionsVehicleIdGetScopesEnum = {
        Info: 'info',
        StopTimes: 'stop_times',
        Shapes: 'shapes',
        VehicleDescriptor: 'vehicle_descriptor'
    } as const;
    export type V2PublicVehiclepositionsVehicleIdGetScopesEnum = typeof V2PublicVehiclepositionsVehicleIdGetScopesEnum[keyof typeof V2PublicVehiclepositionsVehicleIdGetScopesEnum];
    /**
     * @export
     */
    export const V2PublicVehiclepositionsVehicleIdGetAcceptEncodingEnum = {
        Gzip: 'gzip',
        Identity: 'identity'
    } as const;
    export type V2PublicVehiclepositionsVehicleIdGetAcceptEncodingEnum = typeof V2PublicVehiclepositionsVehicleIdGetAcceptEncodingEnum[keyof typeof V2PublicVehiclepositionsVehicleIdGetAcceptEncodingEnum];
    
    
    /**
     * Query parameters for v2PublicVehiclepositionsVehicleIdGet operation in PublicVehiclePositionsV2Api.
     * @export
     * @interface PublicVehiclePositionsV2ApiV2PublicVehiclepositionsVehicleIdGetQueryParams
     */
    export interface PublicVehiclePositionsV2ApiV2PublicVehiclepositionsVehicleIdGetQueryParams {
        //scopesisEnumScopesEnum
        /**
         * Choose which scopes to include in response.
         * @type {Array<'info' | 'stop_times' | 'shapes' | 'vehicle_descriptor'>}
         * @memberof PublicVehiclePositionsV2ApiV2PublicVehiclepositionsVehicleIdGet
         */
        scopes: Array<V2PublicVehiclepositionsVehicleIdGetScopesEnum>
    }
    
    
    /**
     * Header parameters for v2PublicVehiclepositionsVehicleIdGet operation in PublicVehiclePositionsV2Api.
     * @export
     * @interface PublicVehiclePositionsV2ApiV2PublicVehiclepositionsVehicleIdGetHeaderParams
     */
    export interface PublicVehiclePositionsV2ApiV2PublicVehiclepositionsVehicleIdGetHeaderParams {
        /**
         * Indicate the content encoding (usually a compression algorithm) that the client can understand. See [mdn](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding) for more details. Note that for this endpoint, if no value is given, gzip compression will be used by default (the &#x60;identity&#x60; value can be used to opt out of the default compression).
         * @type {'gzip' | 'identity'}
         * @memberof PublicVehiclePositionsV2ApiV2PublicVehiclepositionsVehicleIdGet
         */
        acceptEncoding?: V2PublicVehiclepositionsVehicleIdGetAcceptEncodingEnum
    }
    
    
    /**
     * @export
     */
    export const V2PublicVehiclepositionsVehicleIdgtfsTripIdGetScopesEnum = {
        Info: 'info',
        StopTimes: 'stop_times',
        Shapes: 'shapes',
        VehicleDescriptor: 'vehicle_descriptor'
    } as const;
    export type V2PublicVehiclepositionsVehicleIdgtfsTripIdGetScopesEnum = typeof V2PublicVehiclepositionsVehicleIdgtfsTripIdGetScopesEnum[keyof typeof V2PublicVehiclepositionsVehicleIdgtfsTripIdGetScopesEnum];
    /**
     * @export
     */
    export const V2PublicVehiclepositionsVehicleIdgtfsTripIdGetAcceptEncodingEnum = {
        Gzip: 'gzip',
        Identity: 'identity'
    } as const;
    export type V2PublicVehiclepositionsVehicleIdgtfsTripIdGetAcceptEncodingEnum = typeof V2PublicVehiclepositionsVehicleIdgtfsTripIdGetAcceptEncodingEnum[keyof typeof V2PublicVehiclepositionsVehicleIdgtfsTripIdGetAcceptEncodingEnum];
    
    
    /**
     * Query parameters for v2PublicVehiclepositionsVehicleIdgtfsTripIdGet operation in PublicVehiclePositionsV2Api.
     * @export
     * @interface PublicVehiclePositionsV2ApiV2PublicVehiclepositionsVehicleIdgtfsTripIdGetQueryParams
     */
    export interface PublicVehiclePositionsV2ApiV2PublicVehiclepositionsVehicleIdgtfsTripIdGetQueryParams {
        //scopesisEnumScopesEnum
        /**
         * Choose which scopes to include in response.
         * @type {Array<'info' | 'stop_times' | 'shapes' | 'vehicle_descriptor'>}
         * @memberof PublicVehiclePositionsV2ApiV2PublicVehiclepositionsVehicleIdgtfsTripIdGet
         */
        scopes: Array<V2PublicVehiclepositionsVehicleIdgtfsTripIdGetScopesEnum>
    }
    
    
    /**
     * Header parameters for v2PublicVehiclepositionsVehicleIdgtfsTripIdGet operation in PublicVehiclePositionsV2Api.
     * @export
     * @interface PublicVehiclePositionsV2ApiV2PublicVehiclepositionsVehicleIdgtfsTripIdGetHeaderParams
     */
    export interface PublicVehiclePositionsV2ApiV2PublicVehiclepositionsVehicleIdgtfsTripIdGetHeaderParams {
        /**
         * Indicate the content encoding (usually a compression algorithm) that the client can understand. See [mdn](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding) for more details. Note that for this endpoint, if no value is given, gzip compression will be used by default (the &#x60;identity&#x60; value can be used to opt out of the default compression).
         * @type {'gzip' | 'identity'}
         * @memberof PublicVehiclePositionsV2ApiV2PublicVehiclepositionsVehicleIdgtfsTripIdGet
         */
        acceptEncoding?: V2PublicVehiclepositionsVehicleIdgtfsTripIdGetAcceptEncodingEnum
    }
    
    
    
    /**
     * PublicVehiclePositionsV2Api - object-oriented interface
     * @export
     * @class PublicVehiclePositionsV2Api
     * @extends {BaseAPI}
     */
    export class PublicVehiclePositionsV2Api extends BaseAPI {
    
        constructor(protected override configuration: GolemioPublicTransportApiConfiguration, protected override axios: AxiosInstance = globalAxios) {
            super(configuration, configuration.basePath, axios);
        }
    
        /**
         * ‚ÑπÔ∏è Note: This endpoint is optimized for client applications serving many users simultaneously. It provides streamlined data structures and caching strategies suitable for client-side consumption. Rate limits can be adjusted upon request - contact us if you need higher limits. Note: Despite the \'public\' prefix, this endpoint requires an API key for access control and usage monitoring. 
         * @summary GET All Vehicle Positions
    
         * @param {PublicVehiclePositionsV2ApiV2PublicVehiclepositionsGetQueryParams} queryParams Query parameters.
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof PublicVehiclePositionsV2Api
         */
        
        public async v2PublicVehiclepositionsGet(
            queryParams: PublicVehiclePositionsV2ApiV2PublicVehiclepositionsGetQueryParams = {},
            headerParams: PublicVehiclePositionsV2ApiV2PublicVehiclepositionsGetHeaderParams = {},
            options: AxiosRequestConfig = {}
        ) {
    
            const localVarPath = `/v2/public/vehiclepositions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
            if (queryParams.boundingBox !== undefined) {
                requestQueryParameter['boundingBox'] = queryParams.boundingBox;
            }
    
            if (queryParams.routeShortName) {
                requestQueryParameter['routeShortName'] = queryParams.routeShortName;
            }
    
            if (queryParams.routeType) {
                requestQueryParameter['routeType'] = queryParams.routeType;
            }
    
            if (headerParams.acceptEncoding != null) {
                requestHeaderParameter['Accept-Encoding'] = String(headerParams.acceptEncoding);
            }
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<V2PublicVehiclepositionsGet200Response>(axiosRequestConfig);
        }
    
        /**
         * ‚ÑπÔ∏è Note: This endpoint is optimized for client applications serving many users simultaneously. It provides streamlined data structures and caching strategies suitable for client-side consumption. Rate limits can be adjusted upon request - contact us if you need higher limits. Note: Despite the \'public\' prefix, this endpoint requires an API key for access control and usage monitoring. 
         * @summary GET Vehicle Positions
    
         * @param {string} vehicleId Filter result by vehicle ID (same as *vehicle_id* from the &#x60;/public/vehiclepositions&#x60; EP or *id* from GTFS-RT &#x60;VehicleDescriptor&#x60;) No stop waypoints are not included.
         * @param {PublicVehiclePositionsV2ApiV2PublicVehiclepositionsVehicleIdGetQueryParams} queryParams Query parameters.
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof PublicVehiclePositionsV2Api
         */
        
        public async v2PublicVehiclepositionsVehicleIdGet(
            vehicleId: string,
            queryParams: PublicVehiclePositionsV2ApiV2PublicVehiclepositionsVehicleIdGetQueryParams,
            headerParams: PublicVehiclePositionsV2ApiV2PublicVehiclepositionsVehicleIdGetHeaderParams,
            options: AxiosRequestConfig = {}
        ) {
    
            // verify required parameter 'vehicleId' is not null or undefined
            assertParamExists('v2PublicVehiclepositionsVehicleIdGet', 'vehicleId', vehicleId)
            assertParamExists('v2PublicVehiclepositionsVehicleIdGet', 'scopes', queryParams.scopes)
            
            // verify required parameter 'scopes' is not null or undefined
            assertParamExists('v2PublicVehiclepositionsVehicleIdGet', 'vehicleId', vehicleId)
            assertParamExists('v2PublicVehiclepositionsVehicleIdGet', 'scopes', queryParams.scopes)
            
            const localVarPath = `/v2/public/vehiclepositions/{vehicleId}`
                .replace(`{${"vehicleId"}}`, encodeURIComponent(String(vehicleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
            if (queryParams.scopes) {
                requestQueryParameter['scopes'] = queryParams.scopes;
            }
    
            if (headerParams.acceptEncoding != null) {
                requestHeaderParameter['Accept-Encoding'] = String(headerParams.acceptEncoding);
            }
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<V2PublicVehiclepositionsVehicleIdGet200Response>(axiosRequestConfig);
        }
    
        /**
         * Same as `/public/vehiclepositions/{vehicleId}` but with additional lookup by GTFS trip ID. This may be useful when vehicle is serving the previous trip and you want to get info about the next trip. Combination of `vehicleId` and `gtfsTripId` is needed because multiple vehicles can serve the same trip, and we want to select the correct one. `gtfsTripId` is specified as a path matrix parameter. <br><br>Example: `/public/vehiclepositions/service-3-1001;gtfsTripId=115_107_180501`  ‚ÑπÔ∏è Note: This endpoint is optimized for client applications serving many users simultaneously. It provides streamlined data structures and caching strategies suitable for client-side consumption. Rate limits can be adjusted upon request - contact us if you need higher limits. Note: Despite the \'public\' prefix, this endpoint requires an API key for access control and usage monitoring. 
         * @summary GET Vehicle RT data (additional lookup)
    
         * @param {string} vehicleId Filter result by vehicle ID (same as *vehicle_id* from the &#x60;/public/vehiclepositions&#x60; EP or *id* from GTFS-RT &#x60;VehicleDescriptor&#x60;).
         * @param {string} gtfsTripId Perform additional lookup by GTFS trip ID.
         * @param {PublicVehiclePositionsV2ApiV2PublicVehiclepositionsVehicleIdgtfsTripIdGetQueryParams} queryParams Query parameters.
         * @param {AxiosRequestConfig} [options] Override http request option.
         * @throws {RequiredError}
         * @memberof PublicVehiclePositionsV2Api
         */
        
        public async v2PublicVehiclepositionsVehicleIdgtfsTripIdGet(
            vehicleId: string,
            gtfsTripId: string,
            queryParams: PublicVehiclePositionsV2ApiV2PublicVehiclepositionsVehicleIdgtfsTripIdGetQueryParams,
            headerParams: PublicVehiclePositionsV2ApiV2PublicVehiclepositionsVehicleIdgtfsTripIdGetHeaderParams,
            options: AxiosRequestConfig = {}
        ) {
    
            // verify required parameter 'vehicleId' is not null or undefined
            assertParamExists('v2PublicVehiclepositionsVehicleIdgtfsTripIdGet', 'vehicleId', vehicleId)
            assertParamExists('v2PublicVehiclepositionsVehicleIdgtfsTripIdGet', 'gtfsTripId', gtfsTripId)
            assertParamExists('v2PublicVehiclepositionsVehicleIdgtfsTripIdGet', 'scopes', queryParams.scopes)
            
            // verify required parameter 'gtfsTripId' is not null or undefined
            assertParamExists('v2PublicVehiclepositionsVehicleIdgtfsTripIdGet', 'vehicleId', vehicleId)
            assertParamExists('v2PublicVehiclepositionsVehicleIdgtfsTripIdGet', 'gtfsTripId', gtfsTripId)
            assertParamExists('v2PublicVehiclepositionsVehicleIdgtfsTripIdGet', 'scopes', queryParams.scopes)
            
            // verify required parameter 'scopes' is not null or undefined
            assertParamExists('v2PublicVehiclepositionsVehicleIdgtfsTripIdGet', 'vehicleId', vehicleId)
            assertParamExists('v2PublicVehiclepositionsVehicleIdgtfsTripIdGet', 'gtfsTripId', gtfsTripId)
            assertParamExists('v2PublicVehiclepositionsVehicleIdgtfsTripIdGet', 'scopes', queryParams.scopes)
            
            const localVarPath = `/v2/public/vehiclepositions/{vehicleId}{gtfsTripId}`
                .replace(`{${"vehicleId"}}`, encodeURIComponent(String(vehicleId)))
                .replace(`{${"gtfsTripId"}}`, encodeURIComponent(String(gtfsTripId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const requestUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (this.configuration) {
                baseOptions = this.configuration.baseOptions;
            }
    
            const axiosRequestConfig: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const requestHeaderParameter = {} as any;
            const requestQueryParameter = {} as any;
    
            // authentication ApiKeyAuth required
            await setApiKeyToObject(requestHeaderParameter, "X-Access-Token", this.configuration)
    
            if (queryParams.scopes) {
                requestQueryParameter['scopes'] = queryParams.scopes;
            }
    
            if (headerParams.acceptEncoding != null) {
                requestHeaderParameter['Accept-Encoding'] = String(headerParams.acceptEncoding);
            }
    
    
    
            setSearchParams(requestUrlObj, requestQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            axiosRequestConfig.headers = {...requestHeaderParameter, ...headersFromBaseOptions, ...options.headers};
    
            axiosRequestConfig["url"] = toPathString(requestUrlObj);
            axiosRequestConfig["baseURL"] = this.configuration.basePath;
            
            return this.axios.request<V2PublicVehiclepositionsVehicleIdGet200Response>(axiosRequestConfig);
        }
    }
    
        
}